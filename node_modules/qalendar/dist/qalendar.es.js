var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { defineComponent, computed, watch, h, resolveComponent, openBlock, createElementBlock, normalizeClass, createVNode, createElementVNode, toDisplayString, createCommentVNode, Fragment, createTextVNode, renderList, withDirectives, vShow, useCssVars, normalizeStyle, createBlock, renderSlot, withModifiers, withCtx, Comment, Text, pushScopeId, popScopeId, Transition } from "vue";
class Helpers {
  static getBrowserNavigatorLocale() {
    if (typeof navigator !== "object")
      return "en-US";
    return navigator.languages && navigator.languages.length ? navigator.languages[0] : navigator.language;
  }
}
class EDate extends Date {
  get fullYear() {
    return this.getFullYear();
  }
  get month() {
    return this.getMonth();
  }
  get date() {
    return this.getDate();
  }
}
class Time {
  constructor(firstDayOfWeek = "monday", locale = null, dayBoundaries = { start: 0, end: 2400 }) {
    __publicField(this, "FIRST_DAY_OF_WEEK");
    __publicField(this, "CALENDAR_LOCALE");
    __publicField(this, "ALL_HOURS");
    __publicField(this, "DAY_START");
    __publicField(this, "DAY_END");
    __publicField(this, "HOURS_PER_DAY", 24);
    __publicField(this, "MS_PER_DAY");
    this.FIRST_DAY_OF_WEEK = firstDayOfWeek;
    this.CALENDAR_LOCALE = locale ? locale : Helpers.getBrowserNavigatorLocale();
    this.ALL_HOURS = [
      0,
      100,
      200,
      300,
      400,
      500,
      600,
      700,
      800,
      900,
      1e3,
      1100,
      1200,
      1300,
      1400,
      1500,
      1600,
      1700,
      1800,
      1900,
      2e3,
      2100,
      2200,
      2300,
      2400
    ];
    this.DAY_START = dayBoundaries.start;
    this.DAY_END = dayBoundaries.end;
    this.HOURS_PER_DAY = (() => {
      const convertTimePointToHours = (timePoint) => {
        if (timePoint === 0)
          return 0;
        return timePoint / 100;
      };
      return convertTimePointToHours(this.DAY_END) - convertTimePointToHours(this.DAY_START);
    })();
    this.MS_PER_DAY = 864e5;
  }
  getDatesBetweenTwoDates(start, end) {
    for (var arr = [], dt = new Date(start); dt <= end; dt.setDate(dt.getDate() + 1)) {
      arr.push(new Date(dt.getFullYear(), dt.getMonth(), dt.getDate()));
    }
    return arr;
  }
  getCalendarWeekDateObjects(date = null) {
    const selectedDate = date ? date : new Date();
    let subtractedDaysToGetFirstDate;
    if (this.FIRST_DAY_OF_WEEK === "sunday")
      subtractedDaysToGetFirstDate = selectedDate.getDay();
    else
      subtractedDaysToGetFirstDate = selectedDate.getDay() === 0 ? 6 : selectedDate.getDay() - 1;
    const dateOfFirstDayOfWeek = selectedDate.getDate() - subtractedDaysToGetFirstDate;
    const firstDay = new Date(
      selectedDate.getFullYear(),
      selectedDate.getMonth(),
      dateOfFirstDayOfWeek
    );
    return this.getDatesBetweenTwoDates(
      firstDay,
      new Date(
        firstDay.getFullYear(),
        firstDay.getMonth(),
        firstDay.getDate() + 6
      )
    );
  }
  getCalendarMonthSplitInWeeks(yyyy, mm) {
    const month = [];
    const selectedDate = ![typeof yyyy, typeof mm].includes("undefined") ? new Date(yyyy, mm, 1) : new Date();
    let firstDateOfMonth = new Date(
      selectedDate.getFullYear(),
      selectedDate.getMonth(),
      1
    );
    const firstWeekOfMonth = this.getCalendarWeekDateObjects(firstDateOfMonth);
    month.push(firstWeekOfMonth);
    let isInMonth = true;
    let mondayOfWeekToPush = firstWeekOfMonth[0];
    const specifiedMonth = selectedDate.getMonth();
    while (isInMonth) {
      const newMonday = new Date(
        mondayOfWeekToPush.getFullYear(),
        mondayOfWeekToPush.getMonth(),
        mondayOfWeekToPush.getDate() + 7
      );
      if (newMonday.getMonth() === specifiedMonth) {
        month.push(this.getCalendarWeekDateObjects(newMonday));
        mondayOfWeekToPush = newMonday;
      } else {
        isInMonth = false;
      }
    }
    return month;
  }
  getCalendarYearMonths(year = null) {
    const selectedYear = year ? year : new Date().getFullYear();
    const yearList = [];
    let month = 0;
    while (month <= 11) {
      yearList.push(new Date(selectedYear, month, 1));
      month++;
    }
    return yearList;
  }
  getHourAndMinutesFromTimePoints(timePoints) {
    const time2 = timePoints.toString();
    let hour = "0";
    let minutes = "0";
    if (time2.length === 4) {
      hour = time2[0] + time2[1];
      minutes = time2[2] + time2[3];
    } else if (time2.length === 3) {
      hour = time2[0];
      minutes = time2[1] + time2[2];
    }
    return {
      hour: +hour,
      minutes: +minutes
    };
  }
  getHourLocaleStringFromHourDigits(timePoints) {
    const { hour, minutes } = this.getHourAndMinutesFromTimePoints(timePoints);
    const hourLocaleString = new Date(
      2100,
      0,
      1,
      +hour,
      +minutes,
      0
    ).toLocaleTimeString(this.CALENDAR_LOCALE, {
      hour: "2-digit"
    });
    if (hourLocaleString[0] === "0")
      return hourLocaleString.substring(1);
    return hourLocaleString;
  }
  getLocalizedNameOfWeekday(date, weekdayNameLength = "short") {
    return date.toLocaleDateString(this.CALENDAR_LOCALE, {
      weekday: weekdayNameLength
    });
  }
  getLocalizedNameOfMonth(date, monthNameLength = "short") {
    return date.toLocaleDateString(this.CALENDAR_LOCALE, {
      month: monthNameLength
    });
  }
  getLocalizedDateString(date) {
    return date.toLocaleDateString(this.CALENDAR_LOCALE);
  }
  getDateTimeStringFromDate(date, timeIsStartOrEndOfDay) {
    const y = date.getFullYear();
    const m = date.getMonth() + 1;
    const d2 = date.getDate();
    const fullDate = `${y}-${m >= 10 ? m : "0" + m}-${d2 >= 10 ? d2 : "0" + d2}`;
    if (!timeIsStartOrEndOfDay) {
      const hour = date.getHours();
      const minutes = date.getMinutes();
      return `${fullDate} ${hour >= 10 ? hour : "0" + hour}:${minutes >= 10 ? minutes : "0" + minutes}`;
    }
    const fullTime = timeIsStartOrEndOfDay === "start" ? "00:00" : "23:59";
    return `${fullDate} ${fullTime}`;
  }
  getLocalizedTime(dateTimeString) {
    const h2 = dateTimeString.substring(11, 13);
    const m = dateTimeString.substring(14, 16);
    const d2 = new Date();
    d2.setHours(+h2);
    d2.setMinutes(+m);
    return d2.toLocaleTimeString(this.CALENDAR_LOCALE, {
      hour: "numeric",
      minute: "numeric"
    });
  }
  getLocalizedHour(date) {
    return date.toLocaleTimeString(this.CALENDAR_LOCALE, { hour: "2-digit" });
  }
  getAllVariablesFromDateTimeString(dateTimeString) {
    return {
      year: +dateTimeString.substring(0, 4),
      month: +dateTimeString.substring(5, 7) - 1,
      date: +dateTimeString.substring(8, 10),
      hour: +dateTimeString.substring(11, 13),
      minutes: +dateTimeString.substring(14, 16)
    };
  }
  dateIsToday(date) {
    const {
      fullYear: yearToday,
      month: monthToday,
      date: dateToday
    } = new EDate();
    const {
      fullYear: dateYear,
      month: dateMonth,
      date: dateDate
    } = new EDate(date);
    return yearToday === dateYear && monthToday === dateMonth && dateToday === dateDate;
  }
  dateIsInWeek(dateToCheck, week) {
    const { date, month, fullYear } = new EDate(dateToCheck);
    for (const weekDay of week) {
      const dateIsSame = date === weekDay.getDate();
      const monthIsSame = month === weekDay.getMonth();
      const yearIsSame = fullYear === weekDay.getFullYear();
      if (dateIsSame && monthIsSame && yearIsSame)
        return true;
    }
    return false;
  }
  getDateStringFromDate(date) {
    const yyyy = date.getFullYear();
    const mm = date.getMonth() + 1;
    const dd = date.getDate();
    return `${yyyy}-${mm >= 10 ? mm : "0" + mm}-${dd >= 10 ? dd : "0" + dd}`;
  }
  addMinutesToDateTimeString(minutes, dateTimeString) {
    const {
      year: oldYear,
      month: oldMonth,
      date: oldDate,
      hour: oldHour,
      minutes: oldMinutes
    } = this.getAllVariablesFromDateTimeString(dateTimeString);
    const oldDateObject = new Date(oldYear, oldMonth, oldDate, oldHour, oldMinutes);
    const newDateObject = new Date(oldDateObject.getTime() + minutes * 6e4);
    return this.getDateTimeStringFromDate(newDateObject);
  }
  addDaysToDateTimeString(days, dateTimeString) {
    return this.addMinutesToDateTimeString(days * 1440, dateTimeString);
  }
  dateStringsHaveEqualDates(dateTimeString1, dateTimeString2) {
    const { year: year1, month: month1, date: date1 } = this.getAllVariablesFromDateTimeString(dateTimeString1);
    const { year: year2, month: month2, date: date2 } = this.getAllVariablesFromDateTimeString(dateTimeString2);
    return year1 === year2 && month1 === month2 && date1 === date2;
  }
  setDateToEndOfDay(date) {
    return new Date(
      date.getFullYear(),
      date.getMonth(),
      date.getDate(),
      23,
      59,
      59,
      999
    );
  }
  turnMinutesIntoPercentageOfHour(minutes) {
    const oneMinutePercentage = 100 / 60;
    const minutePoints = oneMinutePercentage * minutes;
    if (minutePoints < 10)
      return "0" + minutePoints;
    return minutePoints.toString();
  }
  getPercentageOfDayFromDateTimeString(dateTimeString, dayStart, dayEnd) {
    const pointsInDay = dayEnd - dayStart;
    const hour = dateTimeString.substring(11, 13);
    const minutes = dateTimeString.substring(14, 16);
    const minutesPoints = this.turnMinutesIntoPercentageOfHour(+minutes);
    const eventPoints = +(hour + minutesPoints);
    const eventPointsIntoDay = eventPoints - dayStart;
    return eventPointsIntoDay / pointsInDay * 100;
  }
  setSegmentOfDateTimeString(dateTimeString, segments) {
    if (segments.hour < 0 || segments.hour > 23)
      throw new Error("Invalid hour");
    segments.hour = String(segments.hour < 10 ? "0" + segments.hour : segments.hour);
    dateTimeString = dateTimeString.replace(/\d{2}:/, segments.hour + ":");
    return dateTimeString;
  }
}
/*!
 * Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 */
function _typeof$1(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$1(target, key, source[key]);
    });
  }
  return target;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}
function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _nonIterableSpread$1();
}
function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
      arr2[i] = arr[i];
    return arr2;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArray$1(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
    return Array.from(iter);
}
function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
var noop = function noop2() {
};
var _WINDOW = {};
var _DOCUMENT = {};
var _MUTATION_OBSERVER = null;
var _PERFORMANCE = {
  mark: noop,
  measure: noop
};
try {
  if (typeof window !== "undefined")
    _WINDOW = window;
  if (typeof document !== "undefined")
    _DOCUMENT = document;
  if (typeof MutationObserver !== "undefined")
    _MUTATION_OBSERVER = MutationObserver;
  if (typeof performance !== "undefined")
    _PERFORMANCE = performance;
} catch (e) {
}
var _ref = _WINDOW.navigator || {}, _ref$userAgent = _ref.userAgent, userAgent = _ref$userAgent === void 0 ? "" : _ref$userAgent;
var WINDOW = _WINDOW;
var DOCUMENT = _DOCUMENT;
var PERFORMANCE = _PERFORMANCE;
!!WINDOW.document;
var IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === "function" && typeof DOCUMENT.createElement === "function";
var IS_IE = ~userAgent.indexOf("MSIE") || ~userAgent.indexOf("Trident/");
var NAMESPACE_IDENTIFIER = "___FONT_AWESOME___";
var UNITS_IN_GRID = 16;
var DEFAULT_FAMILY_PREFIX = "fa";
var DEFAULT_REPLACEMENT_CLASS = "svg-inline--fa";
var DATA_FA_I2SVG = "data-fa-i2svg";
(function() {
  try {
    return true;
  } catch (e) {
    return false;
  }
})();
var DUOTONE_CLASSES = {
  GROUP: "group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
};
var initial = WINDOW.FontAwesomeConfig || {};
function getAttrConfig(attr) {
  var element = DOCUMENT.querySelector("script[" + attr + "]");
  if (element) {
    return element.getAttribute(attr);
  }
}
function coerce(val) {
  if (val === "")
    return true;
  if (val === "false")
    return false;
  if (val === "true")
    return true;
  return val;
}
if (DOCUMENT && typeof DOCUMENT.querySelector === "function") {
  var attrs = [["data-family-prefix", "familyPrefix"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  attrs.forEach(function(_ref2) {
    var _ref22 = _slicedToArray(_ref2, 2), attr = _ref22[0], key = _ref22[1];
    var val = coerce(getAttrConfig(attr));
    if (val !== void 0 && val !== null) {
      initial[key] = val;
    }
  });
}
var _default = {
  familyPrefix: DEFAULT_FAMILY_PREFIX,
  replacementClass: DEFAULT_REPLACEMENT_CLASS,
  autoReplaceSvg: true,
  autoAddCss: true,
  autoA11y: true,
  searchPseudoElements: false,
  observeMutations: true,
  mutateApproach: "async",
  keepOriginalSource: true,
  measurePerformance: false,
  showMissingIcons: true
};
var _config = _objectSpread({}, _default, initial);
if (!_config.autoReplaceSvg)
  _config.observeMutations = false;
var config = _objectSpread({}, _config);
WINDOW.FontAwesomeConfig = config;
var w = WINDOW || {};
if (!w[NAMESPACE_IDENTIFIER])
  w[NAMESPACE_IDENTIFIER] = {};
if (!w[NAMESPACE_IDENTIFIER].styles)
  w[NAMESPACE_IDENTIFIER].styles = {};
if (!w[NAMESPACE_IDENTIFIER].hooks)
  w[NAMESPACE_IDENTIFIER].hooks = {};
if (!w[NAMESPACE_IDENTIFIER].shims)
  w[NAMESPACE_IDENTIFIER].shims = [];
var namespace = w[NAMESPACE_IDENTIFIER];
var functions = [];
var listener = function listener2() {
  DOCUMENT.removeEventListener("DOMContentLoaded", listener2);
  loaded = 1;
  functions.map(function(fn) {
    return fn();
  });
};
var loaded = false;
if (IS_DOM) {
  loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
  if (!loaded)
    DOCUMENT.addEventListener("DOMContentLoaded", listener);
}
var PENDING = "pending";
var SETTLED = "settled";
var FULFILLED = "fulfilled";
var REJECTED = "rejected";
var NOOP = function NOOP2() {
};
var isNode = typeof global !== "undefined" && typeof global.process !== "undefined" && typeof global.process.emit === "function";
var asyncSetTimer = typeof setImmediate === "undefined" ? setTimeout : setImmediate;
var asyncQueue = [];
var asyncTimer;
function asyncFlush() {
  for (var i = 0; i < asyncQueue.length; i++) {
    asyncQueue[i][0](asyncQueue[i][1]);
  }
  asyncQueue = [];
  asyncTimer = false;
}
function asyncCall(callback, arg) {
  asyncQueue.push([callback, arg]);
  if (!asyncTimer) {
    asyncTimer = true;
    asyncSetTimer(asyncFlush, 0);
  }
}
function invokeResolver(resolver, promise) {
  function resolvePromise(value) {
    resolve(promise, value);
  }
  function rejectPromise(reason) {
    reject(promise, reason);
  }
  try {
    resolver(resolvePromise, rejectPromise);
  } catch (e) {
    rejectPromise(e);
  }
}
function invokeCallback(subscriber) {
  var owner = subscriber.owner;
  var settled = owner._state;
  var value = owner._data;
  var callback = subscriber[settled];
  var promise = subscriber.then;
  if (typeof callback === "function") {
    settled = FULFILLED;
    try {
      value = callback(value);
    } catch (e) {
      reject(promise, e);
    }
  }
  if (!handleThenable(promise, value)) {
    if (settled === FULFILLED) {
      resolve(promise, value);
    }
    if (settled === REJECTED) {
      reject(promise, value);
    }
  }
}
function handleThenable(promise, value) {
  var resolved;
  try {
    if (promise === value) {
      throw new TypeError("A promises callback cannot return that same promise.");
    }
    if (value && (typeof value === "function" || _typeof$1(value) === "object")) {
      var then2 = value.then;
      if (typeof then2 === "function") {
        then2.call(value, function(val) {
          if (!resolved) {
            resolved = true;
            if (value === val) {
              fulfill(promise, val);
            } else {
              resolve(promise, val);
            }
          }
        }, function(reason) {
          if (!resolved) {
            resolved = true;
            reject(promise, reason);
          }
        });
        return true;
      }
    }
  } catch (e) {
    if (!resolved) {
      reject(promise, e);
    }
    return true;
  }
  return false;
}
function resolve(promise, value) {
  if (promise === value || !handleThenable(promise, value)) {
    fulfill(promise, value);
  }
}
function fulfill(promise, value) {
  if (promise._state === PENDING) {
    promise._state = SETTLED;
    promise._data = value;
    asyncCall(publishFulfillment, promise);
  }
}
function reject(promise, reason) {
  if (promise._state === PENDING) {
    promise._state = SETTLED;
    promise._data = reason;
    asyncCall(publishRejection, promise);
  }
}
function publish(promise) {
  promise._then = promise._then.forEach(invokeCallback);
}
function publishFulfillment(promise) {
  promise._state = FULFILLED;
  publish(promise);
}
function publishRejection(promise) {
  promise._state = REJECTED;
  publish(promise);
  if (!promise._handled && isNode) {
    global.process.emit("unhandledRejection", promise._data, promise);
  }
}
function notifyRejectionHandled(promise) {
  global.process.emit("rejectionHandled", promise);
}
function P(resolver) {
  if (typeof resolver !== "function") {
    throw new TypeError("Promise resolver " + resolver + " is not a function");
  }
  if (this instanceof P === false) {
    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
  }
  this._then = [];
  invokeResolver(resolver, this);
}
P.prototype = {
  constructor: P,
  _state: PENDING,
  _then: null,
  _data: void 0,
  _handled: false,
  then: function then(onFulfillment, onRejection) {
    var subscriber = {
      owner: this,
      then: new this.constructor(NOOP),
      fulfilled: onFulfillment,
      rejected: onRejection
    };
    if ((onRejection || onFulfillment) && !this._handled) {
      this._handled = true;
      if (this._state === REJECTED && isNode) {
        asyncCall(notifyRejectionHandled, this);
      }
    }
    if (this._state === FULFILLED || this._state === REJECTED) {
      asyncCall(invokeCallback, subscriber);
    } else {
      this._then.push(subscriber);
    }
    return subscriber.then;
  },
  catch: function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};
P.all = function(promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError("You must pass an array to Promise.all().");
  }
  return new P(function(resolve2, reject2) {
    var results = [];
    var remaining = 0;
    function resolver(index) {
      remaining++;
      return function(value) {
        results[index] = value;
        if (!--remaining) {
          resolve2(results);
        }
      };
    }
    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];
      if (promise && typeof promise.then === "function") {
        promise.then(resolver(i), reject2);
      } else {
        results[i] = promise;
      }
    }
    if (!remaining) {
      resolve2(results);
    }
  });
};
P.race = function(promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError("You must pass an array to Promise.race().");
  }
  return new P(function(resolve2, reject2) {
    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];
      if (promise && typeof promise.then === "function") {
        promise.then(resolve2, reject2);
      } else {
        resolve2(promise);
      }
    }
  });
};
P.resolve = function(value) {
  if (value && _typeof$1(value) === "object" && value.constructor === P) {
    return value;
  }
  return new P(function(resolve2) {
    resolve2(value);
  });
};
P.reject = function(reason) {
  return new P(function(resolve2, reject2) {
    reject2(reason);
  });
};
var d = UNITS_IN_GRID;
var meaninglessTransform = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: false,
  flipY: false
};
function insertCss(css2) {
  if (!css2 || !IS_DOM) {
    return;
  }
  var style = DOCUMENT.createElement("style");
  style.setAttribute("type", "text/css");
  style.innerHTML = css2;
  var headChildren = DOCUMENT.head.childNodes;
  var beforeChild = null;
  for (var i = headChildren.length - 1; i > -1; i--) {
    var child = headChildren[i];
    var tagName = (child.tagName || "").toUpperCase();
    if (["STYLE", "LINK"].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }
  DOCUMENT.head.insertBefore(style, beforeChild);
  return css2;
}
var idPool = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function nextUniqueId() {
  var size = 12;
  var id = "";
  while (size-- > 0) {
    id += idPool[Math.random() * 62 | 0];
  }
  return id;
}
function htmlEscape(str) {
  return "".concat(str).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function joinAttributes(attributes) {
  return Object.keys(attributes || {}).reduce(function(acc, attributeName) {
    return acc + "".concat(attributeName, '="').concat(htmlEscape(attributes[attributeName]), '" ');
  }, "").trim();
}
function joinStyles(styles2) {
  return Object.keys(styles2 || {}).reduce(function(acc, styleName) {
    return acc + "".concat(styleName, ": ").concat(styles2[styleName], ";");
  }, "");
}
function transformIsMeaningful(transform2) {
  return transform2.size !== meaninglessTransform.size || transform2.x !== meaninglessTransform.x || transform2.y !== meaninglessTransform.y || transform2.rotate !== meaninglessTransform.rotate || transform2.flipX || transform2.flipY;
}
function transformForSvg(_ref2) {
  var transform2 = _ref2.transform, containerWidth = _ref2.containerWidth, iconWidth = _ref2.iconWidth;
  var outer = {
    transform: "translate(".concat(containerWidth / 2, " 256)")
  };
  var innerTranslate = "translate(".concat(transform2.x * 32, ", ").concat(transform2.y * 32, ") ");
  var innerScale = "scale(".concat(transform2.size / 16 * (transform2.flipX ? -1 : 1), ", ").concat(transform2.size / 16 * (transform2.flipY ? -1 : 1), ") ");
  var innerRotate = "rotate(".concat(transform2.rotate, " 0 0)");
  var inner = {
    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
  };
  var path = {
    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
  };
  return {
    outer,
    inner,
    path
  };
}
function transformForCss(_ref2) {
  var transform2 = _ref2.transform, _ref2$width = _ref2.width, width = _ref2$width === void 0 ? UNITS_IN_GRID : _ref2$width, _ref2$height = _ref2.height, height = _ref2$height === void 0 ? UNITS_IN_GRID : _ref2$height, _ref2$startCentered = _ref2.startCentered, startCentered = _ref2$startCentered === void 0 ? false : _ref2$startCentered;
  var val = "";
  if (startCentered && IS_IE) {
    val += "translate(".concat(transform2.x / d - width / 2, "em, ").concat(transform2.y / d - height / 2, "em) ");
  } else if (startCentered) {
    val += "translate(calc(-50% + ".concat(transform2.x / d, "em), calc(-50% + ").concat(transform2.y / d, "em)) ");
  } else {
    val += "translate(".concat(transform2.x / d, "em, ").concat(transform2.y / d, "em) ");
  }
  val += "scale(".concat(transform2.size / d * (transform2.flipX ? -1 : 1), ", ").concat(transform2.size / d * (transform2.flipY ? -1 : 1), ") ");
  val += "rotate(".concat(transform2.rotate, "deg) ");
  return val;
}
var ALL_SPACE = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function fillBlack(abstract) {
  var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (abstract.attributes && (abstract.attributes.fill || force)) {
    abstract.attributes.fill = "black";
  }
  return abstract;
}
function deGroup(abstract) {
  if (abstract.tag === "g") {
    return abstract.children;
  } else {
    return [abstract];
  }
}
function makeIconMasking(_ref2) {
  var children = _ref2.children, attributes = _ref2.attributes, main = _ref2.main, mask = _ref2.mask, explicitMaskId = _ref2.maskId, transform2 = _ref2.transform;
  var mainWidth = main.width, mainPath = main.icon;
  var maskWidth = mask.width, maskPath = mask.icon;
  var trans = transformForSvg({
    transform: transform2,
    containerWidth: maskWidth,
    iconWidth: mainWidth
  });
  var maskRect = {
    tag: "rect",
    attributes: _objectSpread({}, ALL_SPACE, {
      fill: "white"
    })
  };
  var maskInnerGroupChildrenMixin = mainPath.children ? {
    children: mainPath.children.map(fillBlack)
  } : {};
  var maskInnerGroup = {
    tag: "g",
    attributes: _objectSpread({}, trans.inner),
    children: [fillBlack(_objectSpread({
      tag: mainPath.tag,
      attributes: _objectSpread({}, mainPath.attributes, trans.path)
    }, maskInnerGroupChildrenMixin))]
  };
  var maskOuterGroup = {
    tag: "g",
    attributes: _objectSpread({}, trans.outer),
    children: [maskInnerGroup]
  };
  var maskId = "mask-".concat(explicitMaskId || nextUniqueId());
  var clipId = "clip-".concat(explicitMaskId || nextUniqueId());
  var maskTag = {
    tag: "mask",
    attributes: _objectSpread({}, ALL_SPACE, {
      id: maskId,
      maskUnits: "userSpaceOnUse",
      maskContentUnits: "userSpaceOnUse"
    }),
    children: [maskRect, maskOuterGroup]
  };
  var defs = {
    tag: "defs",
    children: [{
      tag: "clipPath",
      attributes: {
        id: clipId
      },
      children: deGroup(maskPath)
    }, maskTag]
  };
  children.push(defs, {
    tag: "rect",
    attributes: _objectSpread({
      fill: "currentColor",
      "clip-path": "url(#".concat(clipId, ")"),
      mask: "url(#".concat(maskId, ")")
    }, ALL_SPACE)
  });
  return {
    children,
    attributes
  };
}
function makeIconStandard(_ref2) {
  var children = _ref2.children, attributes = _ref2.attributes, main = _ref2.main, transform2 = _ref2.transform, styles2 = _ref2.styles;
  var styleString = joinStyles(styles2);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  if (transformIsMeaningful(transform2)) {
    var trans = transformForSvg({
      transform: transform2,
      containerWidth: main.width,
      iconWidth: main.width
    });
    children.push({
      tag: "g",
      attributes: _objectSpread({}, trans.outer),
      children: [{
        tag: "g",
        attributes: _objectSpread({}, trans.inner),
        children: [{
          tag: main.icon.tag,
          children: main.icon.children,
          attributes: _objectSpread({}, main.icon.attributes, trans.path)
        }]
      }]
    });
  } else {
    children.push(main.icon);
  }
  return {
    children,
    attributes
  };
}
function asIcon(_ref2) {
  var children = _ref2.children, main = _ref2.main, mask = _ref2.mask, attributes = _ref2.attributes, styles2 = _ref2.styles, transform2 = _ref2.transform;
  if (transformIsMeaningful(transform2) && main.found && !mask.found) {
    var width = main.width, height = main.height;
    var offset = {
      x: width / height / 2,
      y: 0.5
    };
    attributes["style"] = joinStyles(_objectSpread({}, styles2, {
      "transform-origin": "".concat(offset.x + transform2.x / 16, "em ").concat(offset.y + transform2.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes,
    children
  }];
}
function asSymbol(_ref2) {
  var prefix = _ref2.prefix, iconName = _ref2.iconName, children = _ref2.children, attributes = _ref2.attributes, symbol = _ref2.symbol;
  var id = symbol === true ? "".concat(prefix, "-").concat(config.familyPrefix, "-").concat(iconName) : symbol;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: _objectSpread({}, attributes, {
        id
      }),
      children
    }]
  }];
}
function makeInlineSvgAbstract(params) {
  var _params$icons = params.icons, main = _params$icons.main, mask = _params$icons.mask, prefix = params.prefix, iconName = params.iconName, transform2 = params.transform, symbol = params.symbol, title = params.title, maskId = params.maskId, titleId = params.titleId, extra = params.extra, _params$watchable = params.watchable, watchable = _params$watchable === void 0 ? false : _params$watchable;
  var _ref2 = mask.found ? mask : main, width = _ref2.width, height = _ref2.height;
  var isUploadedIcon = prefix === "fak";
  var widthClass = isUploadedIcon ? "" : "fa-w-".concat(Math.ceil(width / height * 16));
  var attrClass = [config.replacementClass, iconName ? "".concat(config.familyPrefix, "-").concat(iconName) : "", widthClass].filter(function(c) {
    return extra.classes.indexOf(c) === -1;
  }).filter(function(c) {
    return c !== "" || !!c;
  }).concat(extra.classes).join(" ");
  var content = {
    children: [],
    attributes: _objectSpread({}, extra.attributes, {
      "data-prefix": prefix,
      "data-icon": iconName,
      "class": attrClass,
      "role": extra.attributes.role || "img",
      "xmlns": "http://www.w3.org/2000/svg",
      "viewBox": "0 0 ".concat(width, " ").concat(height)
    })
  };
  var uploadedIconWidthStyle = isUploadedIcon && !~extra.classes.indexOf("fa-fw") ? {
    width: "".concat(width / height * 16 * 0.0625, "em")
  } : {};
  if (watchable) {
    content.attributes[DATA_FA_I2SVG] = "";
  }
  if (title)
    content.children.push({
      tag: "title",
      attributes: {
        id: content.attributes["aria-labelledby"] || "title-".concat(titleId || nextUniqueId())
      },
      children: [title]
    });
  var args = _objectSpread({}, content, {
    prefix,
    iconName,
    main,
    mask,
    maskId,
    transform: transform2,
    symbol,
    styles: _objectSpread({}, uploadedIconWidthStyle, extra.styles)
  });
  var _ref22 = mask.found && main.found ? makeIconMasking(args) : makeIconStandard(args), children = _ref22.children, attributes = _ref22.attributes;
  args.children = children;
  args.attributes = attributes;
  if (symbol) {
    return asSymbol(args);
  } else {
    return asIcon(args);
  }
}
function makeLayersTextAbstract(params) {
  var content = params.content, width = params.width, height = params.height, transform2 = params.transform, title = params.title, extra = params.extra, _params$watchable2 = params.watchable, watchable = _params$watchable2 === void 0 ? false : _params$watchable2;
  var attributes = _objectSpread({}, extra.attributes, title ? {
    "title": title
  } : {}, {
    "class": extra.classes.join(" ")
  });
  if (watchable) {
    attributes[DATA_FA_I2SVG] = "";
  }
  var styles2 = _objectSpread({}, extra.styles);
  if (transformIsMeaningful(transform2)) {
    styles2["transform"] = transformForCss({
      transform: transform2,
      startCentered: true,
      width,
      height
    });
    styles2["-webkit-transform"] = styles2["transform"];
  }
  var styleString = joinStyles(styles2);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  var val = [];
  val.push({
    tag: "span",
    attributes,
    children: [content]
  });
  if (title) {
    val.push({
      tag: "span",
      attributes: {
        class: "sr-only"
      },
      children: [title]
    });
  }
  return val;
}
var noop$1 = function noop3() {
};
config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
  mark: noop$1,
  measure: noop$1
};
var bindInternal4 = function bindInternal42(func, thisContext) {
  return function(a, b, c, d2) {
    return func.call(thisContext, a, b, c, d2);
  };
};
var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
  var keys = Object.keys(subject), length = keys.length, iterator = thisContext !== void 0 ? bindInternal4(fn, thisContext) : fn, i, key, result;
  if (initialValue === void 0) {
    i = 1;
    result = subject[keys[0]];
  } else {
    i = 0;
    result = initialValue;
  }
  for (; i < length; i++) {
    key = keys[i];
    result = iterator(result, subject[key], key, subject);
  }
  return result;
};
function defineIcons(prefix, icons) {
  var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _params$skipHooks = params.skipHooks, skipHooks = _params$skipHooks === void 0 ? false : _params$skipHooks;
  var normalized = Object.keys(icons).reduce(function(acc, iconName) {
    var icon2 = icons[iconName];
    var expanded = !!icon2.icon;
    if (expanded) {
      acc[icon2.iconName] = icon2.icon;
    } else {
      acc[iconName] = icon2;
    }
    return acc;
  }, {});
  if (typeof namespace.hooks.addPack === "function" && !skipHooks) {
    namespace.hooks.addPack(prefix, normalized);
  } else {
    namespace.styles[prefix] = _objectSpread({}, namespace.styles[prefix] || {}, normalized);
  }
  if (prefix === "fas") {
    defineIcons("fa", icons);
  }
}
var styles = namespace.styles, shims = namespace.shims;
var build = function build2() {
  var lookup = function lookup2(reducer) {
    return reduce(styles, function(o, style, prefix) {
      o[prefix] = reduce(style, reducer, {});
      return o;
    }, {});
  };
  lookup(function(acc, icon2, iconName) {
    if (icon2[3]) {
      acc[icon2[3]] = iconName;
    }
    return acc;
  });
  lookup(function(acc, icon2, iconName) {
    var ligatures = icon2[2];
    acc[iconName] = iconName;
    ligatures.forEach(function(ligature) {
      acc[ligature] = iconName;
    });
    return acc;
  });
  var hasRegular = "far" in styles;
  reduce(shims, function(acc, shim) {
    var oldName = shim[0];
    var prefix = shim[1];
    var iconName = shim[2];
    if (prefix === "far" && !hasRegular) {
      prefix = "fas";
    }
    acc[oldName] = {
      prefix,
      iconName
    };
    return acc;
  }, {});
};
build();
namespace.styles;
function iconFromMapping(mapping, prefix, iconName) {
  if (mapping && mapping[prefix] && mapping[prefix][iconName]) {
    return {
      prefix,
      iconName,
      icon: mapping[prefix][iconName]
    };
  }
}
function toHtml(abstractNodes) {
  var tag = abstractNodes.tag, _abstractNodes$attrib = abstractNodes.attributes, attributes = _abstractNodes$attrib === void 0 ? {} : _abstractNodes$attrib, _abstractNodes$childr = abstractNodes.children, children = _abstractNodes$childr === void 0 ? [] : _abstractNodes$childr;
  if (typeof abstractNodes === "string") {
    return htmlEscape(abstractNodes);
  } else {
    return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children.map(toHtml).join(""), "</").concat(tag, ">");
  }
}
var parseTransformString = function parseTransformString2(transformString) {
  var transform2 = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };
  if (!transformString) {
    return transform2;
  } else {
    return transformString.toLowerCase().split(" ").reduce(function(acc, n) {
      var parts = n.toLowerCase().split("-");
      var first = parts[0];
      var rest = parts.slice(1).join("-");
      if (first && rest === "h") {
        acc.flipX = true;
        return acc;
      }
      if (first && rest === "v") {
        acc.flipY = true;
        return acc;
      }
      rest = parseFloat(rest);
      if (isNaN(rest)) {
        return acc;
      }
      switch (first) {
        case "grow":
          acc.size = acc.size + rest;
          break;
        case "shrink":
          acc.size = acc.size - rest;
          break;
        case "left":
          acc.x = acc.x - rest;
          break;
        case "right":
          acc.x = acc.x + rest;
          break;
        case "up":
          acc.y = acc.y - rest;
          break;
        case "down":
          acc.y = acc.y + rest;
          break;
        case "rotate":
          acc.rotate = acc.rotate + rest;
          break;
      }
      return acc;
    }, transform2);
  }
};
function MissingIcon(error) {
  this.name = "MissingIcon";
  this.message = error || "Icon unavailable";
  this.stack = new Error().stack;
}
MissingIcon.prototype = Object.create(Error.prototype);
MissingIcon.prototype.constructor = MissingIcon;
var FILL = {
  fill: "currentColor"
};
var ANIMATION_BASE = {
  attributeType: "XML",
  repeatCount: "indefinite",
  dur: "2s"
};
({
  tag: "path",
  attributes: _objectSpread({}, FILL, {
    d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
  })
});
var OPACITY_ANIMATE = _objectSpread({}, ANIMATION_BASE, {
  attributeName: "opacity"
});
({
  tag: "circle",
  attributes: _objectSpread({}, FILL, {
    cx: "256",
    cy: "364",
    r: "28"
  }),
  children: [{
    tag: "animate",
    attributes: _objectSpread({}, ANIMATION_BASE, {
      attributeName: "r",
      values: "28;14;28;28;14;28;"
    })
  }, {
    tag: "animate",
    attributes: _objectSpread({}, OPACITY_ANIMATE, {
      values: "1;0;1;1;0;1;"
    })
  }]
});
({
  tag: "path",
  attributes: _objectSpread({}, FILL, {
    opacity: "1",
    d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
  }),
  children: [{
    tag: "animate",
    attributes: _objectSpread({}, OPACITY_ANIMATE, {
      values: "1;0;0;0;0;1;"
    })
  }]
});
({
  tag: "path",
  attributes: _objectSpread({}, FILL, {
    opacity: "0",
    d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
  }),
  children: [{
    tag: "animate",
    attributes: _objectSpread({}, OPACITY_ANIMATE, {
      values: "0;0;1;1;0;0;"
    })
  }]
});
namespace.styles;
function asFoundIcon(icon2) {
  var width = icon2[0];
  var height = icon2[1];
  var _icon$slice = icon2.slice(4), _icon$slice2 = _slicedToArray(_icon$slice, 1), vectorData = _icon$slice2[0];
  var element = null;
  if (Array.isArray(vectorData)) {
    element = {
      tag: "g",
      attributes: {
        class: "".concat(config.familyPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
      },
      children: [{
        tag: "path",
        attributes: {
          class: "".concat(config.familyPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
          fill: "currentColor",
          d: vectorData[0]
        }
      }, {
        tag: "path",
        attributes: {
          class: "".concat(config.familyPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
          fill: "currentColor",
          d: vectorData[1]
        }
      }]
    };
  } else {
    element = {
      tag: "path",
      attributes: {
        fill: "currentColor",
        d: vectorData
      }
    };
  }
  return {
    found: true,
    width,
    height,
    icon: element
  };
}
namespace.styles;
var baseStyles = 'svg:not(:root).svg-inline--fa {\n  overflow: visible;\n}\n\n.svg-inline--fa {\n  display: inline-block;\n  font-size: inherit;\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.225em;\n}\n.svg-inline--fa.fa-w-1 {\n  width: 0.0625em;\n}\n.svg-inline--fa.fa-w-2 {\n  width: 0.125em;\n}\n.svg-inline--fa.fa-w-3 {\n  width: 0.1875em;\n}\n.svg-inline--fa.fa-w-4 {\n  width: 0.25em;\n}\n.svg-inline--fa.fa-w-5 {\n  width: 0.3125em;\n}\n.svg-inline--fa.fa-w-6 {\n  width: 0.375em;\n}\n.svg-inline--fa.fa-w-7 {\n  width: 0.4375em;\n}\n.svg-inline--fa.fa-w-8 {\n  width: 0.5em;\n}\n.svg-inline--fa.fa-w-9 {\n  width: 0.5625em;\n}\n.svg-inline--fa.fa-w-10 {\n  width: 0.625em;\n}\n.svg-inline--fa.fa-w-11 {\n  width: 0.6875em;\n}\n.svg-inline--fa.fa-w-12 {\n  width: 0.75em;\n}\n.svg-inline--fa.fa-w-13 {\n  width: 0.8125em;\n}\n.svg-inline--fa.fa-w-14 {\n  width: 0.875em;\n}\n.svg-inline--fa.fa-w-15 {\n  width: 0.9375em;\n}\n.svg-inline--fa.fa-w-16 {\n  width: 1em;\n}\n.svg-inline--fa.fa-w-17 {\n  width: 1.0625em;\n}\n.svg-inline--fa.fa-w-18 {\n  width: 1.125em;\n}\n.svg-inline--fa.fa-w-19 {\n  width: 1.1875em;\n}\n.svg-inline--fa.fa-w-20 {\n  width: 1.25em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-border {\n  height: 1.5em;\n}\n.svg-inline--fa.fa-li {\n  width: 2em;\n}\n.svg-inline--fa.fa-fw {\n  width: 1.25em;\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: #ff253a;\n  border-radius: 1em;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: #fff;\n  height: 1.5em;\n  line-height: 1;\n  max-width: 5em;\n  min-width: 1.5em;\n  overflow: hidden;\n  padding: 0.25em;\n  right: 0;\n  text-overflow: ellipsis;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: 0;\n  right: 0;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: 0;\n  left: 0;\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  right: 0;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: 0;\n  right: auto;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-lg {\n  font-size: 1.3333333333em;\n  line-height: 0.75em;\n  vertical-align: -0.0667em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: 2.5em;\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: -2em;\n  position: absolute;\n  text-align: center;\n  width: 2em;\n  line-height: inherit;\n}\n\n.fa-border {\n  border: solid 0.08em #eee;\n  border-radius: 0.1em;\n  padding: 0.2em 0.25em 0.15em;\n}\n\n.fa-pull-left {\n  float: left;\n}\n\n.fa-pull-right {\n  float: right;\n}\n\n.fa.fa-pull-left,\n.fas.fa-pull-left,\n.far.fa-pull-left,\n.fal.fa-pull-left,\n.fab.fa-pull-left {\n  margin-right: 0.3em;\n}\n.fa.fa-pull-right,\n.fas.fa-pull-right,\n.far.fa-pull-right,\n.fal.fa-pull-right,\n.fab.fa-pull-right {\n  margin-left: 0.3em;\n}\n\n.fa-spin {\n  -webkit-animation: fa-spin 2s infinite linear;\n          animation: fa-spin 2s infinite linear;\n}\n\n.fa-pulse {\n  -webkit-animation: fa-spin 1s infinite steps(8);\n          animation: fa-spin 1s infinite steps(8);\n}\n\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both, .fa-flip-horizontal.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n:root .fa-rotate-90,\n:root .fa-rotate-180,\n:root .fa-rotate-270,\n:root .fa-flip-horizontal,\n:root .fa-flip-vertical,\n:root .fa-flip-both {\n  -webkit-filter: none;\n          filter: none;\n}\n\n.fa-stack {\n  display: inline-block;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: #fff;\n}\n\n.sr-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px;\n}\n\n.sr-only-focusable:active, .sr-only-focusable:focus {\n  clip: auto;\n  height: auto;\n  margin: 0;\n  overflow: visible;\n  position: static;\n  width: auto;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: 1;\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: 0.4;\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: 0.4;\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: 1;\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse {\n  color: #fff;\n}';
function css() {
  var dfp = DEFAULT_FAMILY_PREFIX;
  var drc = DEFAULT_REPLACEMENT_CLASS;
  var fp = config.familyPrefix;
  var rc = config.replacementClass;
  var s = baseStyles;
  if (fp !== dfp || rc !== drc) {
    var dPatt = new RegExp("\\.".concat(dfp, "\\-"), "g");
    var customPropPatt = new RegExp("\\--".concat(dfp, "\\-"), "g");
    var rPatt = new RegExp("\\.".concat(drc), "g");
    s = s.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc));
  }
  return s;
}
var Library = /* @__PURE__ */ function() {
  function Library2() {
    _classCallCheck(this, Library2);
    this.definitions = {};
  }
  _createClass(Library2, [{
    key: "add",
    value: function add() {
      var _this = this;
      for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
        definitions[_key] = arguments[_key];
      }
      var additions = definitions.reduce(this._pullDefinitions, {});
      Object.keys(additions).forEach(function(key) {
        _this.definitions[key] = _objectSpread({}, _this.definitions[key] || {}, additions[key]);
        defineIcons(key, additions[key]);
        build();
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function _pullDefinitions(additions, definition) {
      var normalized = definition.prefix && definition.iconName && definition.icon ? {
        0: definition
      } : definition;
      Object.keys(normalized).map(function(key) {
        var _normalized$key = normalized[key], prefix = _normalized$key.prefix, iconName = _normalized$key.iconName, icon2 = _normalized$key.icon;
        if (!additions[prefix])
          additions[prefix] = {};
        additions[prefix][iconName] = icon2;
      });
      return additions;
    }
  }]);
  return Library2;
}();
function ensureCss() {
  if (config.autoAddCss && !_cssInserted) {
    insertCss(css());
    _cssInserted = true;
  }
}
function apiObject(val, abstractCreator) {
  Object.defineProperty(val, "abstract", {
    get: abstractCreator
  });
  Object.defineProperty(val, "html", {
    get: function get2() {
      return val.abstract.map(function(a) {
        return toHtml(a);
      });
    }
  });
  Object.defineProperty(val, "node", {
    get: function get2() {
      if (!IS_DOM)
        return;
      var container = DOCUMENT.createElement("div");
      container.innerHTML = val.html;
      return container.children;
    }
  });
  return val;
}
function findIconDefinition(iconLookup) {
  var _iconLookup$prefix = iconLookup.prefix, prefix = _iconLookup$prefix === void 0 ? "fa" : _iconLookup$prefix, iconName = iconLookup.iconName;
  if (!iconName)
    return;
  return iconFromMapping(library.definitions, prefix, iconName) || iconFromMapping(namespace.styles, prefix, iconName);
}
function resolveIcons(next) {
  return function(maybeIconDefinition) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
    var mask = params.mask;
    if (mask) {
      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
    }
    return next(iconDefinition, _objectSpread({}, params, {
      mask
    }));
  };
}
var library = new Library();
var _cssInserted = false;
var parse = {
  transform: function transform(transformString) {
    return parseTransformString(transformString);
  }
};
var icon = resolveIcons(function(iconDefinition) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _params$transform = params.transform, transform2 = _params$transform === void 0 ? meaninglessTransform : _params$transform, _params$symbol = params.symbol, symbol = _params$symbol === void 0 ? false : _params$symbol, _params$mask = params.mask, mask = _params$mask === void 0 ? null : _params$mask, _params$maskId = params.maskId, maskId = _params$maskId === void 0 ? null : _params$maskId, _params$title = params.title, title = _params$title === void 0 ? null : _params$title, _params$titleId = params.titleId, titleId = _params$titleId === void 0 ? null : _params$titleId, _params$classes = params.classes, classes = _params$classes === void 0 ? [] : _params$classes, _params$attributes = params.attributes, attributes = _params$attributes === void 0 ? {} : _params$attributes, _params$styles = params.styles, styles2 = _params$styles === void 0 ? {} : _params$styles;
  if (!iconDefinition)
    return;
  var prefix = iconDefinition.prefix, iconName = iconDefinition.iconName, icon2 = iconDefinition.icon;
  return apiObject(_objectSpread({
    type: "icon"
  }, iconDefinition), function() {
    ensureCss();
    if (config.autoA11y) {
      if (title) {
        attributes["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
      } else {
        attributes["aria-hidden"] = "true";
        attributes["focusable"] = "false";
      }
    }
    return makeInlineSvgAbstract({
      icons: {
        main: asFoundIcon(icon2),
        mask: mask ? asFoundIcon(mask.icon) : {
          found: false,
          width: null,
          height: null,
          icon: {}
        }
      },
      prefix,
      iconName,
      transform: _objectSpread({}, meaninglessTransform, transform2),
      symbol,
      title,
      maskId,
      titleId,
      extra: {
        attributes,
        styles: styles2,
        classes
      }
    });
  });
});
var text = function text2(content) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _params$transform2 = params.transform, transform2 = _params$transform2 === void 0 ? meaninglessTransform : _params$transform2, _params$title2 = params.title, title = _params$title2 === void 0 ? null : _params$title2, _params$classes2 = params.classes, classes = _params$classes2 === void 0 ? [] : _params$classes2, _params$attributes2 = params.attributes, attributes = _params$attributes2 === void 0 ? {} : _params$attributes2, _params$styles2 = params.styles, styles2 = _params$styles2 === void 0 ? {} : _params$styles2;
  return apiObject({
    type: "text",
    content
  }, function() {
    ensureCss();
    return makeLayersTextAbstract({
      content,
      transform: _objectSpread({}, meaninglessTransform, transform2),
      title,
      extra: {
        attributes,
        styles: styles2,
        classes: ["".concat(config.familyPrefix, "-layers-text")].concat(_toConsumableArray$1(classes))
      }
    });
  });
};
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var humps$1 = { exports: {} };
(function(module) {
  (function(global2) {
    var _processKeys = function(convert2, obj, options) {
      if (!_isObject(obj) || _isDate(obj) || _isRegExp(obj) || _isBoolean(obj) || _isFunction(obj)) {
        return obj;
      }
      var output, i = 0, l = 0;
      if (_isArray(obj)) {
        output = [];
        for (l = obj.length; i < l; i++) {
          output.push(_processKeys(convert2, obj[i], options));
        }
      } else {
        output = {};
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            output[convert2(key, options)] = _processKeys(convert2, obj[key], options);
          }
        }
      }
      return output;
    };
    var separateWords = function(string, options) {
      options = options || {};
      var separator = options.separator || "_";
      var split = options.split || /(?=[A-Z])/;
      return string.split(split).join(separator);
    };
    var camelize = function(string) {
      if (_isNumerical(string)) {
        return string;
      }
      string = string.replace(/[\-_\s]+(.)?/g, function(match, chr) {
        return chr ? chr.toUpperCase() : "";
      });
      return string.substr(0, 1).toLowerCase() + string.substr(1);
    };
    var pascalize = function(string) {
      var camelized = camelize(string);
      return camelized.substr(0, 1).toUpperCase() + camelized.substr(1);
    };
    var decamelize = function(string, options) {
      return separateWords(string, options).toLowerCase();
    };
    var toString = Object.prototype.toString;
    var _isFunction = function(obj) {
      return typeof obj === "function";
    };
    var _isObject = function(obj) {
      return obj === Object(obj);
    };
    var _isArray = function(obj) {
      return toString.call(obj) == "[object Array]";
    };
    var _isDate = function(obj) {
      return toString.call(obj) == "[object Date]";
    };
    var _isRegExp = function(obj) {
      return toString.call(obj) == "[object RegExp]";
    };
    var _isBoolean = function(obj) {
      return toString.call(obj) == "[object Boolean]";
    };
    var _isNumerical = function(obj) {
      obj = obj - 0;
      return obj === obj;
    };
    var _processor = function(convert2, options) {
      var callback = options && "process" in options ? options.process : options;
      if (typeof callback !== "function") {
        return convert2;
      }
      return function(string, options2) {
        return callback(string, convert2, options2);
      };
    };
    var humps2 = {
      camelize,
      decamelize,
      pascalize,
      depascalize: decamelize,
      camelizeKeys: function(object, options) {
        return _processKeys(_processor(camelize, options), object);
      },
      decamelizeKeys: function(object, options) {
        return _processKeys(_processor(decamelize, options), object, options);
      },
      pascalizeKeys: function(object, options) {
        return _processKeys(_processor(pascalize, options), object);
      },
      depascalizeKeys: function() {
        return this.decamelizeKeys.apply(this, arguments);
      }
    };
    if (module.exports) {
      module.exports = humps2;
    } else {
      global2.humps = humps2;
    }
  })(commonjsGlobal);
})(humps$1);
var humps = humps$1.exports;
var _excluded = ["class", "style"];
function styleToObject(style) {
  return style.split(";").map(function(s) {
    return s.trim();
  }).filter(function(s) {
    return s;
  }).reduce(function(output, pair) {
    var idx = pair.indexOf(":");
    var prop = humps.camelize(pair.slice(0, idx));
    var value = pair.slice(idx + 1).trim();
    output[prop] = value;
    return output;
  }, {});
}
function classToObject(classes) {
  return classes.split(/\s+/).reduce(function(output, className) {
    output[className] = true;
    return output;
  }, {});
}
function convert(abstractElement) {
  var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var attrs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof abstractElement === "string") {
    return abstractElement;
  }
  var children = (abstractElement.children || []).map(function(child) {
    return convert(child);
  });
  var mixins = Object.keys(abstractElement.attributes || {}).reduce(function(mixins2, key) {
    var value = abstractElement.attributes[key];
    switch (key) {
      case "class":
        mixins2.class = classToObject(value);
        break;
      case "style":
        mixins2.style = styleToObject(value);
        break;
      default:
        mixins2.attrs[key] = value;
    }
    return mixins2;
  }, {
    attrs: {},
    class: {},
    style: {}
  });
  attrs.class;
  var _attrs$style = attrs.style, aStyle = _attrs$style === void 0 ? {} : _attrs$style, otherAttrs = _objectWithoutProperties(attrs, _excluded);
  return h(abstractElement.tag, _objectSpread2(_objectSpread2(_objectSpread2({}, props), {}, {
    class: mixins.class,
    style: _objectSpread2(_objectSpread2({}, mixins.style), aStyle)
  }, mixins.attrs), otherAttrs), children);
}
var PRODUCTION = false;
try {
  PRODUCTION = true;
} catch (e) {
}
function log() {
  if (!PRODUCTION && console && typeof console.error === "function") {
    var _console;
    (_console = console).error.apply(_console, arguments);
  }
}
function objectWithKey(key, value) {
  return Array.isArray(value) && value.length > 0 || !Array.isArray(value) && value ? _defineProperty({}, key, value) : {};
}
function classList(props) {
  var _classes;
  var classes = (_classes = {
    "fa-spin": props.spin,
    "fa-pulse": props.pulse,
    "fa-fw": props.fixedWidth,
    "fa-border": props.border,
    "fa-li": props.listItem,
    "fa-inverse": props.inverse,
    "fa-flip": props.flip === true,
    "fa-flip-horizontal": props.flip === "horizontal" || props.flip === "both",
    "fa-flip-vertical": props.flip === "vertical" || props.flip === "both"
  }, _defineProperty(_classes, "fa-".concat(props.size), props.size !== null), _defineProperty(_classes, "fa-rotate-".concat(props.rotation), props.rotation !== null), _defineProperty(_classes, "fa-pull-".concat(props.pull), props.pull !== null), _defineProperty(_classes, "fa-swap-opacity", props.swapOpacity), _defineProperty(_classes, "fa-bounce", props.bounce), _defineProperty(_classes, "fa-shake", props.shake), _defineProperty(_classes, "fa-beat", props.beat), _defineProperty(_classes, "fa-fade", props.fade), _defineProperty(_classes, "fa-beat-fade", props.beatFade), _defineProperty(_classes, "fa-flash", props.flash), _defineProperty(_classes, "fa-spin-pulse", props.spinPulse), _defineProperty(_classes, "fa-spin-reverse", props.spinReverse), _classes);
  return Object.keys(classes).map(function(key) {
    return classes[key] ? key : null;
  }).filter(function(key) {
    return key;
  });
}
function normalizeIconArgs(icon2) {
  if (icon2 && _typeof(icon2) === "object" && icon2.prefix && icon2.iconName && icon2.icon) {
    return icon2;
  }
  if (parse.icon) {
    return parse.icon(icon2);
  }
  if (icon2 === null) {
    return null;
  }
  if (_typeof(icon2) === "object" && icon2.prefix && icon2.iconName) {
    return icon2;
  }
  if (Array.isArray(icon2) && icon2.length === 2) {
    return {
      prefix: icon2[0],
      iconName: icon2[1]
    };
  }
  if (typeof icon2 === "string") {
    return {
      prefix: "fas",
      iconName: icon2
    };
  }
}
var FontAwesomeIcon = defineComponent({
  name: "FontAwesomeIcon",
  props: {
    border: {
      type: Boolean,
      default: false
    },
    fixedWidth: {
      type: Boolean,
      default: false
    },
    flip: {
      type: [Boolean, String],
      default: false,
      validator: function validator(value) {
        return [true, false, "horizontal", "vertical", "both"].indexOf(value) > -1;
      }
    },
    icon: {
      type: [Object, Array, String],
      required: true
    },
    mask: {
      type: [Object, Array, String],
      default: null
    },
    listItem: {
      type: Boolean,
      default: false
    },
    pull: {
      type: String,
      default: null,
      validator: function validator2(value) {
        return ["right", "left"].indexOf(value) > -1;
      }
    },
    pulse: {
      type: Boolean,
      default: false
    },
    rotation: {
      type: [String, Number],
      default: null,
      validator: function validator3(value) {
        return [90, 180, 270].indexOf(Number.parseInt(value, 10)) > -1;
      }
    },
    swapOpacity: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: null,
      validator: function validator4(value) {
        return ["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"].indexOf(value) > -1;
      }
    },
    spin: {
      type: Boolean,
      default: false
    },
    transform: {
      type: [String, Object],
      default: null
    },
    symbol: {
      type: [Boolean, String],
      default: false
    },
    title: {
      type: String,
      default: null
    },
    inverse: {
      type: Boolean,
      default: false
    },
    bounce: {
      type: Boolean,
      default: false
    },
    shake: {
      type: Boolean,
      default: false
    },
    beat: {
      type: Boolean,
      default: false
    },
    fade: {
      type: Boolean,
      default: false
    },
    beatFade: {
      type: Boolean,
      default: false
    },
    flash: {
      type: Boolean,
      default: false
    },
    spinPulse: {
      type: Boolean,
      default: false
    },
    spinReverse: {
      type: Boolean,
      default: false
    }
  },
  setup: function setup(props, _ref2) {
    var attrs = _ref2.attrs;
    var icon$1 = computed(function() {
      return normalizeIconArgs(props.icon);
    });
    var classes = computed(function() {
      return objectWithKey("classes", classList(props));
    });
    var transform2 = computed(function() {
      return objectWithKey("transform", typeof props.transform === "string" ? parse.transform(props.transform) : props.transform);
    });
    var mask = computed(function() {
      return objectWithKey("mask", normalizeIconArgs(props.mask));
    });
    var renderedIcon = computed(function() {
      return icon(icon$1.value, _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, classes.value), transform2.value), mask.value), {}, {
        symbol: props.symbol,
        title: props.title
      }));
    });
    watch(renderedIcon, function(value) {
      if (!value) {
        return log("Could not find one or more icon(s)", icon$1.value, mask.value);
      }
    }, {
      immediate: true
    });
    var vnode = computed(function() {
      return renderedIcon.value ? convert(renderedIcon.value.abstract[0], {}, attrs) : null;
    });
    return function() {
      return vnode.value;
    };
  }
});
defineComponent({
  name: "FontAwesomeLayers",
  props: {
    fixedWidth: {
      type: Boolean,
      default: false
    }
  },
  setup: function setup2(props, _ref2) {
    var slots = _ref2.slots;
    var familyPrefix = config.familyPrefix;
    var className = computed(function() {
      return ["".concat(familyPrefix, "-layers")].concat(_toConsumableArray(props.fixedWidth ? ["".concat(familyPrefix, "-fw")] : []));
    });
    return function() {
      return h("div", {
        class: className.value
      }, slots.default ? slots.default() : []);
    };
  }
});
defineComponent({
  name: "FontAwesomeLayersText",
  props: {
    value: {
      type: [String, Number],
      default: ""
    },
    transform: {
      type: [String, Object],
      default: null
    },
    counter: {
      type: Boolean,
      default: false
    },
    position: {
      type: String,
      default: null,
      validator: function validator5(value) {
        return ["bottom-left", "bottom-right", "top-left", "top-right"].indexOf(value) > -1;
      }
    }
  },
  setup: function setup3(props, _ref2) {
    var attrs = _ref2.attrs;
    var familyPrefix = config.familyPrefix;
    var classes = computed(function() {
      return objectWithKey("classes", [].concat(_toConsumableArray(props.counter ? ["".concat(familyPrefix, "-layers-counter")] : []), _toConsumableArray(props.position ? ["".concat(familyPrefix, "-layers-").concat(props.position)] : [])));
    });
    var transform2 = computed(function() {
      return objectWithKey("transform", typeof props.transform === "string" ? parse.transform(props.transform) : props.transform);
    });
    var abstractElement = computed(function() {
      var _text = text(props.value.toString(), _objectSpread2(_objectSpread2({}, transform2.value), classes.value)), abstract = _text.abstract;
      if (props.counter) {
        abstract[0].attributes.class = abstract[0].attributes.class.replace("fa-layers-text", "");
      }
      return abstract[0];
    });
    var vnode = computed(function() {
      return convert(abstractElement.value, {}, attrs);
    });
    return function() {
      return vnode.value;
    };
  }
});
/*!
 * Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 */
var faCalendarDay = {
  prefix: "fas",
  iconName: "calendar-day",
  icon: [448, 512, [], "f783", "M0 464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V192H0v272zm64-192c0-8.8 7.2-16 16-16h96c8.8 0 16 7.2 16 16v96c0 8.8-7.2 16-16 16H80c-8.8 0-16-7.2-16-16v-96zM400 64h-48V16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v48H160V16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v48H48C21.5 64 0 85.5 0 112v48h448v-48c0-26.5-21.5-48-48-48z"]
};
var faChevronCircleLeft = {
  prefix: "fas",
  iconName: "chevron-circle-left",
  icon: [512, 512, [], "f137", "M256 504C119 504 8 393 8 256S119 8 256 8s248 111 248 248-111 248-248 248zM142.1 273l135.5 135.5c9.4 9.4 24.6 9.4 33.9 0l17-17c9.4-9.4 9.4-24.6 0-33.9L226.9 256l101.6-101.6c9.4-9.4 9.4-24.6 0-33.9l-17-17c-9.4-9.4-24.6-9.4-33.9 0L142.1 239c-9.4 9.4-9.4 24.6 0 34z"]
};
var faChevronCircleRight = {
  prefix: "fas",
  iconName: "chevron-circle-right",
  icon: [512, 512, [], "f138", "M256 8c137 0 248 111 248 248S393 504 256 504 8 393 8 256 119 8 256 8zm113.9 231L234.4 103.5c-9.4-9.4-24.6-9.4-33.9 0l-17 17c-9.4 9.4-9.4 24.6 0 33.9L285.1 256 183.5 357.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L369.9 273c9.4-9.4 9.4-24.6 0-34z"]
};
var faChevronLeft = {
  prefix: "fas",
  iconName: "chevron-left",
  icon: [320, 512, [], "f053", "M34.52 239.03L228.87 44.69c9.37-9.37 24.57-9.37 33.94 0l22.67 22.67c9.36 9.36 9.37 24.52.04 33.9L131.49 256l154.02 154.75c9.34 9.38 9.32 24.54-.04 33.9l-22.67 22.67c-9.37 9.37-24.57 9.37-33.94 0L34.52 272.97c-9.37-9.37-9.37-24.57 0-33.94z"]
};
var faChevronRight = {
  prefix: "fas",
  iconName: "chevron-right",
  icon: [320, 512, [], "f054", "M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"]
};
var faClock$1 = {
  prefix: "fas",
  iconName: "clock",
  icon: [512, 512, [], "f017", "M256,8C119,8,8,119,8,256S119,504,256,504,504,393,504,256,393,8,256,8Zm92.49,313h0l-20,25a16,16,0,0,1-22.49,2.5h0l-67-49.72a40,40,0,0,1-15-31.23V112a16,16,0,0,1,16-16h32a16,16,0,0,1,16,16V256l58,42.5A16,16,0,0,1,348.49,321Z"]
};
var faComment$1 = {
  prefix: "fas",
  iconName: "comment",
  icon: [512, 512, [], "f075", "M256 32C114.6 32 0 125.1 0 240c0 49.6 21.4 95 57 130.7C44.5 421.1 2.7 466 2.2 466.5c-2.2 2.3-2.8 5.7-1.5 8.7S4.8 480 8 480c66.3 0 116-31.8 140.6-51.4 32.7 12.3 69 19.4 107.4 19.4 141.4 0 256-93.1 256-208S397.4 32 256 32z"]
};
var faMapMarkerAlt = {
  prefix: "fas",
  iconName: "map-marker-alt",
  icon: [384, 512, [], "f3c5", "M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0zM192 272c44.183 0 80-35.817 80-80s-35.817-80-80-80-80 35.817-80 80 35.817 80 80 80z"]
};
var faQuestionCircle$1 = {
  prefix: "fas",
  iconName: "question-circle",
  icon: [512, 512, [], "f059", "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z"]
};
var faTimes = {
  prefix: "fas",
  iconName: "times",
  icon: [352, 512, [], "f00d", "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"]
};
var faUser$1 = {
  prefix: "fas",
  iconName: "user",
  icon: [448, 512, [], "f007", "M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"]
};
var DatePicker_vue_vue_type_style_index_0_scoped_true_lang = "";
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$c = defineComponent({
  name: "DatePicker",
  components: { FontAwesomeIcon },
  props: {
    mode: {
      type: String,
      default: "week"
    },
    timeProp: {
      type: Object,
      default: null
    },
    periodProp: {
      type: Object,
      default: null
    },
    firstDayOfWeek: {
      type: String,
      default: ""
    },
    defaultDate: {
      type: Date,
      default: new Date()
    },
    locale: {
      type: String,
      default: ""
    },
    disableDates: {
      type: Object,
      default: null
    }
  },
  emits: ["updated"],
  data() {
    var _a, _b;
    return {
      periodText: "",
      weekPickerDates: [],
      monthPickerDates: [],
      icons: {
        calendarIcon: faCalendarDay,
        chevronLeft: faChevronCircleLeft,
        chevronRight: faChevronCircleRight
      },
      showDatePicker: !!(this.locale && this.firstDayOfWeek),
      datePickerCurrentDate: ((_a = this.periodProp) == null ? void 0 : _a.selectedDate) || this.defaultDate || new Date(),
      selectedDate: ((_b = this.periodProp) == null ? void 0 : _b.selectedDate) || new Date(),
      datePickerMode: "month",
      weekDays: [],
      time: this.timeProp ? this.timeProp : new Time(this.firstDayOfWeek, this.locale),
      period: this.periodProp || {
        start: new Date(),
        end: new Date(),
        selectedDate: this.defaultDate ? this.defaultDate : new Date()
      }
    };
  },
  computed: {
    isStandAloneComponent() {
      return this.locale && this.firstDayOfWeek;
    }
  },
  watch: {
    period: {
      deep: true,
      handler() {
        if (this.selectedDate.getTime() === this.period.selectedDate.getTime())
          return;
        this.hydrateDatePicker();
      }
    }
  },
  mounted() {
    this.hydrateDatePicker(true);
  },
  methods: {
    setMonthDaysInWeekPicker(month = new Date().getMonth(), year = new Date().getFullYear()) {
      this.weekPickerDates = [];
      this.weekPickerDates = this.time.getCalendarMonthSplitInWeeks(
        year,
        month
      );
    },
    togglePeriodSelector() {
      this.weekPickerDates = this.time.getCalendarMonthSplitInWeeks(
        this.datePickerCurrentDate.getFullYear(),
        this.datePickerCurrentDate.getMonth()
      );
      this.showDatePicker = !this.showDatePicker;
    },
    setWeek(date, isOnMountHook = false) {
      if (!isOnMountHook)
        this.datePickerCurrentDate = date;
      const currentWeek = this.time.getCalendarWeekDateObjects(date);
      this.weekDays = currentWeek;
      const start = currentWeek[0];
      const end = currentWeek[6];
      switch (this.mode) {
        case "week":
          this.periodText = `${this.time.getLocalizedDateString(
            start
          )} - ${this.time.getLocalizedDateString(end)}`;
          break;
        case "month":
          this.periodText = this.time.getLocalizedNameOfMonth(date);
          break;
        default:
          this.periodText = this.time.getLocalizedDateString(date);
      }
      if (isOnMountHook)
        return;
      this.emitChange(start, end);
    },
    setMonth(date) {
      this.datePickerCurrentDate = date;
      this.setMonthDaysInWeekPicker(date.getMonth(), date.getFullYear());
      this.datePickerMode = "month";
      this.showDatePicker = true;
    },
    emitChange(start, end) {
      this.selectedDate = this.datePickerCurrentDate;
      if (this.mode === "month") {
        const month = this.time.getCalendarMonthSplitInWeeks(
          this.selectedDate.getFullYear(),
          this.selectedDate.getMonth()
        );
        start = month[0][0];
        const lastWeek = month[month.length - 1];
        end = lastWeek[lastWeek.length - 1];
      } else if (this.mode === "day") {
        start = this.selectedDate;
        end = this.selectedDate;
      }
      if (!this.isStandAloneComponent) {
        this.$emit("updated", {
          start: new Date(
            start.getFullYear(),
            start.getMonth(),
            start.getDate(),
            0,
            0,
            0
          ),
          end: this.time.setDateToEndOfDay(end),
          selectedDate: this.datePickerCurrentDate
        });
      } else {
        this.$emit("updated", {
          year: this.datePickerCurrentDate.getFullYear(),
          month: this.datePickerCurrentDate.getMonth(),
          date: this.datePickerCurrentDate.getDate()
        });
      }
    },
    toggleDatePickerPeriod(direction) {
      const currentDate = new Date(this.datePickerCurrentDate);
      if (this.datePickerMode === "month") {
        const dateToSet = new Date(
          currentDate.getFullYear(),
          direction === "previous" ? currentDate.getMonth() - 1 : currentDate.getMonth() + 1,
          1
        );
        this.setMonthDaysInWeekPicker(
          dateToSet.getMonth(),
          dateToSet.getFullYear()
        );
        this.datePickerCurrentDate = dateToSet;
      } else {
        this.monthPickerDates = this.time.getCalendarYearMonths(
          direction === "previous" ? currentDate.getFullYear() - 1 : currentDate.getFullYear() + 1
        );
        this.datePickerCurrentDate = new Date(this.monthPickerDates[0]);
      }
    },
    toggleDatePickerMode() {
      if (this.datePickerMode === "month") {
        this.monthPickerDates = this.time.getCalendarYearMonths(
          this.datePickerCurrentDate.getFullYear()
        );
        return this.datePickerMode = "year";
      }
      if (this.datePickerMode === "year") {
        this.weekPickerDates = this.time.getCalendarMonthSplitInWeeks(
          this.datePickerCurrentDate.getFullYear(),
          this.datePickerCurrentDate.getMonth()
        );
        return this.datePickerMode = "month";
      }
    },
    getLocale() {
      return this.time.CALENDAR_LOCALE;
    },
    goToPeriod(direction) {
      let newDate;
      let newDatePayload;
      if (this.mode === "week") {
        const week = this.time.getCalendarWeekDateObjects(
          this.datePickerCurrentDate
        );
        newDate = new Date(week[0]);
        newDatePayload = direction === "next" ? newDate.getDate() + 7 : newDate.getDate() - 7;
      } else if (this.mode === "month") {
        newDate = new Date(this.datePickerCurrentDate);
        const nDaysNextMonth = new Date(
          this.datePickerCurrentDate.getFullYear(),
          this.datePickerCurrentDate.getMonth() + 2,
          0
        ).getDate();
        const nDaysPreviousMonth = new Date(
          this.datePickerCurrentDate.getFullYear(),
          this.datePickerCurrentDate.getMonth(),
          0
        ).getDate();
        newDatePayload = direction === "next" ? newDate.getDate() + nDaysNextMonth : newDate.getDate() - nDaysPreviousMonth;
      } else {
        newDate = new Date(this.datePickerCurrentDate);
        newDatePayload = direction === "next" ? newDate.getDate() + 1 : newDate.getDate() - 1;
      }
      newDate.setDate(newDatePayload);
      this.setWeek(newDate);
    },
    hideDatePicker() {
      if (!this.isStandAloneComponent)
        setTimeout(() => this.showDatePicker = false, 100);
    },
    hydrateDatePicker(isOnMountHook = false) {
      const date = isOnMountHook ? this.datePickerCurrentDate : this.selectedDate;
      this.setMonthDaysInWeekPicker(date.getMonth(), date.getFullYear());
      this.setWeek(date, isOnMountHook);
    },
    checkIfDateIsDisabled(date) {
      if (!this.disableDates)
        return false;
      if (date.getTime() < this.disableDates.before.getTime())
        return true;
      return date.getTime() > this.disableDates.after.getTime();
    }
  }
});
const _hoisted_1$c = { class: "date-picker__value-display-text" };
const _hoisted_2$a = { class: "date-picker__week-picker-navigation" };
const _hoisted_3$6 = {
  key: 0,
  class: "date-picker__day-names week"
};
const _hoisted_4$6 = ["onClick"];
const _hoisted_5$5 = { class: "months" };
const _hoisted_6$3 = ["onClick"];
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["date-picker", { "date-picker-root": _ctx.isStandAloneComponent }]),
    onMouseleave: _cache[5] || (_cache[5] = (...args) => _ctx.hideDatePicker && _ctx.hideDatePicker(...args))
  }, [
    !_ctx.isStandAloneComponent ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "date-picker__value-display",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.togglePeriodSelector && _ctx.togglePeriodSelector(...args))
    }, [
      createVNode(_component_font_awesome_icon, {
        icon: _ctx.icons.calendarIcon
      }, null, 8, ["icon"]),
      createElementVNode("span", _hoisted_1$c, toDisplayString(_ctx.periodText), 1)
    ])) : createCommentVNode("", true),
    _ctx.showDatePicker ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(["date-picker__week-picker", { "is-in-qalendar": !_ctx.isStandAloneComponent }]),
      onMouseleave: _cache[4] || (_cache[4] = (...args) => _ctx.hideDatePicker && _ctx.hideDatePicker(...args))
    }, [
      createElementVNode("div", _hoisted_2$a, [
        createVNode(_component_font_awesome_icon, {
          class: "is-icon is-chevron-left",
          icon: _ctx.icons.chevronLeft,
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.toggleDatePickerPeriod("previous"))
        }, null, 8, ["icon"]),
        createElementVNode("span", {
          class: "date-picker__toggle-mode",
          onClick: _cache[2] || (_cache[2] = (...args) => _ctx.toggleDatePickerMode && _ctx.toggleDatePickerMode(...args))
        }, [
          _ctx.datePickerMode === "month" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(_ctx.datePickerCurrentDate.toLocaleString(_ctx.getLocale(), {
              month: "long",
              year: "numeric"
            })), 1)
          ], 64)) : _ctx.datePickerMode === "year" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(new Date(_ctx.datePickerCurrentDate).toLocaleString(_ctx.getLocale(), {
              year: "numeric"
            })), 1)
          ], 64)) : createCommentVNode("", true)
        ]),
        createVNode(_component_font_awesome_icon, {
          class: "is-icon is-chevron-right",
          icon: _ctx.icons.chevronRight,
          onClick: _cache[3] || (_cache[3] = ($event) => _ctx.toggleDatePickerPeriod("next"))
        }, null, 8, ["icon"])
      ]),
      _ctx.datePickerMode === "month" ? (openBlock(), createElementBlock("div", _hoisted_3$6, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.weekDays, (day) => {
          return openBlock(), createElementBlock("span", {
            key: day.getDate()
          }, toDisplayString(_ctx.time.getLocalizedNameOfWeekday(day, "short")), 1);
        }), 128))
      ])) : createCommentVNode("", true),
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.weekPickerDates, (week, weekIndex) => {
        return withDirectives((openBlock(), createElementBlock("div", {
          key: weekIndex,
          class: normalizeClass([
            "week",
            _ctx.time.dateIsInWeek(_ctx.selectedDate, week) && !_ctx.isStandAloneComponent ? "is-active" : ""
          ])
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(week, (day, dayIndex) => {
            return openBlock(), createElementBlock("span", {
              key: weekIndex + dayIndex,
              class: normalizeClass({
                "is-weekend": [5, 6].includes(dayIndex),
                "is-not-in-month": day.getMonth() !== _ctx.datePickerCurrentDate.getMonth(),
                "has-day": day,
                "is-today": _ctx.time.dateIsToday(day),
                "is-disabled": _ctx.checkIfDateIsDisabled(day)
              }),
              onClick: ($event) => !_ctx.checkIfDateIsDisabled(day) ? _ctx.setWeek(day) : null
            }, toDisplayString(day ? day.getDate() : ""), 11, _hoisted_4$6);
          }), 128))
        ], 2)), [
          [vShow, _ctx.datePickerMode === "month"]
        ]);
      }), 128)),
      withDirectives(createElementVNode("div", _hoisted_5$5, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.monthPickerDates, (date, monthIndex) => {
          return openBlock(), createElementBlock("span", {
            key: monthIndex,
            class: "has-month",
            onClick: ($event) => _ctx.setMonth(date)
          }, toDisplayString(new Date(date).toLocaleString(_ctx.getLocale(), { month: "long" })), 9, _hoisted_6$3);
        }), 128))
      ], 512), [
        [vShow, _ctx.datePickerMode === "year"]
      ])
    ], 34)) : createCommentVNode("", true)
  ], 34);
}
var DatePicker = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c], ["__scopeId", "data-v-bcffcb1c"]]);
const languageKeys = {
  week: {
    "it-IT": "Settimana",
    "en-US": "Week",
    "de-DE": "Woche",
    "sv-SE": "Vecka",
    "zh-CN": "\u5468",
    "pt-BR": "Semana",
    "fr-FR": "Semaine"
  },
  month: {
    "it-IT": "Mese",
    "en-US": "Month",
    "de-DE": "Monat",
    "sv-SE": "M\xE5nad",
    "zh-CN": "\u6708",
    "pt-BR": "M\xEAs",
    "fr-FR": "Mois"
  },
  day: {
    "it-IT": "Giorno",
    "en-US": "Day",
    "de-DE": "Tag",
    "sv-SE": "Dag",
    "zh-CN": "\u65E5",
    "pt-BR": "Dia",
    "fr-FR": "Jour"
  },
  moreEvents: {
    "it-IT": "+ altri eventi",
    "en-US": "+ more events",
    "de-DE": "+ weitere Ereignisse",
    "sv-SE": "+ fler h\xE4ndelser",
    "zh-CN": "\u5217\u51FA\u5176\u4ED6\u7ED3\u679C",
    "pt-BR": "+ mais eventos",
    "fr-FR": "+ d'autres \xE9v\xE9nements"
  }
};
var getLanguage = {
  data() {
    return {
      languageKeys
    };
  },
  methods: {
    getLanguage(languageKeys2, locale) {
      if (locale.startsWith("de"))
        locale = "de-DE";
      if (locale.startsWith("en"))
        locale = "en-US";
      if (locale.startsWith("it"))
        locale = "it-IT";
      if (locale.startsWith("sv"))
        locale = "sv-SE";
      if (locale.startsWith("zh"))
        locale = "zh-CN";
      if (locale.startsWith("pt"))
        locale = "pt-BR";
      if (locale.startsWith("fr"))
        locale = "fr-FR";
      return languageKeys2[locale] ? languageKeys2[locale] : languageKeys2["en-US"] || "";
    }
  }
};
var Header_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$b = defineComponent({
  name: "AppHeader",
  components: {
    DatePicker,
    FontAwesomeIcon
  },
  mixins: [getLanguage],
  props: {
    config: {
      type: Object,
      default: () => ({})
    },
    mode: {
      type: String,
      default: "week"
    },
    time: {
      type: Object,
      default: () => ({})
    },
    period: {
      type: Object,
      required: true
    },
    isSmall: {
      type: Boolean,
      required: true
    }
  },
  emits: ["change-mode", "updated-period"],
  data() {
    return {
      modeOptions: ["month", "week", "day"],
      icons: {
        chevronLeft: faChevronLeft,
        chevronRight: faChevronRight
      },
      currentPeriod: this.period,
      showModePicker: false
    };
  },
  computed: {
    periodName() {
      var _a, _b, _c;
      if (this.mode === "week") {
        const startMonth = this.time.getLocalizedNameOfMonth(
          (_a = this.currentPeriod) == null ? void 0 : _a.start,
          "short"
        );
        const endMonth = this.time.getLocalizedNameOfMonth(
          (_b = this.currentPeriod) == null ? void 0 : _b.end,
          "short"
        );
        return startMonth === endMonth ? startMonth : `${startMonth} - ${endMonth}`;
      }
      return this.time.getLocalizedNameOfMonth(
        (_c = this.currentPeriod) == null ? void 0 : _c.selectedDate,
        "short"
      ) + " " + this.currentPeriod.selectedDate.getFullYear();
    },
    modeName() {
      var _a;
      return this.getLanguage(
        this.languageKeys[this.mode],
        (_a = this.time) == null ? void 0 : _a.CALENDAR_LOCALE
      );
    },
    onlyDayModeIsEnabled() {
      var _a, _b;
      const weekIsDisabled = (_a = this.config.disableModes) == null ? void 0 : _a.includes("week");
      const monthIsDisabled = (_b = this.config.disableModes) == null ? void 0 : _b.includes("month");
      return this.config.disableModes && weekIsDisabled && monthIsDisabled;
    }
  },
  methods: {
    handlePeriodChange(value) {
      this.currentPeriod = value;
      this.$emit("updated-period", value);
    },
    goToPeriod(event, direction) {
      this.$refs.periodSelect.goToPeriod(direction);
    }
  },
  watch: {
    isSmall: {
      handler(value) {
        if (value)
          this.modeOptions = ["month", "day"];
        else
          this.modeOptions = ["month", "week", "day"];
      },
      immediate: true
    }
  }
});
const _hoisted_1$b = { class: "calendar-header" };
const _hoisted_2$9 = {
  key: 0,
  class: "calendar-header__period-name"
};
const _hoisted_3$5 = { class: "calendar-header__period" };
const _hoisted_4$5 = { class: "calendar-header__chevron-arrows" };
const _hoisted_5$4 = {
  key: 0,
  class: "calendar-header__mode-picker"
};
const _hoisted_6$2 = ["onClick"];
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FontAwesomeIcon = resolveComponent("FontAwesomeIcon");
  const _component_DatePicker = resolveComponent("DatePicker");
  return openBlock(), createElementBlock("div", _hoisted_1$b, [
    _ctx.periodName ? (openBlock(), createElementBlock("div", _hoisted_2$9, toDisplayString(_ctx.periodName), 1)) : createCommentVNode("", true),
    createElementVNode("div", _hoisted_3$5, [
      createElementVNode("div", _hoisted_4$5, [
        createVNode(_component_FontAwesomeIcon, {
          class: "calendar-header__chevron-arrow calendar-header__chevron-arrow-left",
          icon: _ctx.icons.chevronLeft,
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.goToPeriod($event, "previous"))
        }, null, 8, ["icon"]),
        createVNode(_component_FontAwesomeIcon, {
          class: "calendar-header__chevron-arrow calendar-header__chevron-arrow-right",
          icon: _ctx.icons.chevronRight,
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.goToPeriod($event, "next"))
        }, null, 8, ["icon"])
      ]),
      createVNode(_component_DatePicker, {
        ref: "periodSelect",
        mode: _ctx.mode,
        "time-prop": _ctx.time,
        "period-prop": _ctx.period,
        onUpdated: _ctx.handlePeriodChange
      }, null, 8, ["mode", "time-prop", "period-prop", "onUpdated"]),
      !_ctx.onlyDayModeIsEnabled ? (openBlock(), createElementBlock("div", _hoisted_5$4, [
        createElementVNode("div", {
          class: "calendar-header__mode-value",
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.showModePicker = true)
        }, toDisplayString(_ctx.modeName), 1),
        _ctx.showModePicker ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "calendar-header__mode-options",
          onMouseleave: _cache[3] || (_cache[3] = ($event) => _ctx.showModePicker = false)
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.modeOptions, (mode) => {
            return openBlock(), createElementBlock(Fragment, { key: mode }, [
              !_ctx.config.disableModes || !_ctx.config.disableModes.includes(mode) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(["calendar-header__mode-option", "is-" + mode + "-mode"]),
                onClick: ($event) => _ctx.$emit("change-mode", mode)
              }, toDisplayString(_ctx.getLanguage(_ctx.languageKeys[mode], _ctx.time.CALENDAR_LOCALE)), 11, _hoisted_6$2)) : createCommentVNode("", true)
            ], 64);
          }), 128))
        ], 32)) : createCommentVNode("", true)
      ])) : createCommentVNode("", true)
    ])
  ]);
}
var AppHeader = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b], ["__scopeId", "data-v-6976f31b"]]);
var DayTimeline_vue_vue_type_style_index_0_scoped_true_lang = "";
const __default__$4 = defineComponent({
  name: "DayTimeline",
  props: {
    time: {
      type: Object,
      required: true
    },
    weekHeight: {
      type: String,
      required: true
    }
  },
  data() {
    return {
      availableHours: [
        0,
        100,
        200,
        300,
        400,
        500,
        600,
        700,
        800,
        900,
        1e3,
        1100,
        1200,
        1300,
        1400,
        1500,
        1600,
        1700,
        1800,
        1900,
        2e3,
        2100,
        2200,
        2300
      ],
      timelineHours: []
    };
  },
  methods: {
    getLocaleTimeString(time2) {
      const { hour } = this.time.getHourAndMinutesFromTimePoints(time2);
      return this.time.getLocalizedHour(new Date(2100, 1, 1, hour));
    }
  },
  mounted() {
    this.timelineHours = this.availableHours.filter((hour) => {
      return hour >= this.time.DAY_START && hour < this.time.DAY_END;
    });
  }
});
const __injectCSSVars__$4 = () => {
  useCssVars((_ctx) => ({
    "1dbdb798": _ctx.weekHeight
  }));
};
const __setup__$4 = __default__$4.setup;
__default__$4.setup = __setup__$4 ? (props, ctx) => {
  __injectCSSVars__$4();
  return __setup__$4(props, ctx);
} : __injectCSSVars__$4;
const _sfc_main$a = __default__$4;
const _hoisted_1$a = { class: "day-timeline" };
const _hoisted_2$8 = { class: "day-timeline__hour-text" };
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$a, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.timelineHours, (hour) => {
      return openBlock(), createElementBlock("div", {
        key: hour,
        class: "day-timeline__hour"
      }, [
        createElementVNode("span", _hoisted_2$8, toDisplayString(_ctx.getLocaleTimeString(hour)), 1)
      ]);
    }), 128))
  ]);
}
var DayTimeline = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a], ["__scopeId", "data-v-e34d1736"]]);
const EVENT_COLORS = {
  yellow: "rgb(244, 180, 0)",
  blue: "rgba(38, 132, 255)",
  green: "rgb(51, 182, 121)",
  red: "rgb(255, 84, 86)",
  pink: "rgb(239, 139, 239)",
  purple: "rgb(157, 114, 245)",
  turquoise: "rgb(64, 190, 190)",
  brown: "rgb(169, 99, 30)"
};
const DATE_TIME_STRING_PATTERN = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/;
const DATE_TIME_STRING_FULL_DAY_PATTERN = /^\d{4}-\d{2}-\d{2}$/;
var FullDayEvent_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$9 = defineComponent({
  name: "FullDayEvent",
  props: {
    scheduleEvent: {
      type: Object,
      default: null
    },
    config: {
      type: Object,
      required: true
    },
    mode: {
      type: String,
      required: true
    }
  },
  emits: ["event-was-clicked"],
  data() {
    return {
      colors: EVENT_COLORS,
      eventColor: "#fff",
      eventBackgroundColor: "",
      eventElementIdPrefix: "week-timeline__event-id-"
    };
  },
  computed: {
    eventWidth() {
      if (this.mode !== "day")
        return `calc(${this.scheduleEvent.nDays * 100}% - 6px)`;
      return "calc(100% - 6px)";
    }
  },
  mounted() {
    this.setColors();
  },
  methods: {
    setColors() {
      var _a, _b, _c;
      if (((_a = this.scheduleEvent) == null ? void 0 : _a.colorScheme) && ((_b = this.config.style) == null ? void 0 : _b.colorSchemes) && this.config.style.colorSchemes[this.scheduleEvent.colorScheme]) {
        this.eventColor = this.config.style.colorSchemes[this.scheduleEvent.colorScheme].color;
        return this.eventBackgroundColor = this.config.style.colorSchemes[this.scheduleEvent.colorScheme].backgroundColor;
      }
      if ((_c = this.scheduleEvent) == null ? void 0 : _c.color) {
        this.eventColor = "#fff";
        return this.eventBackgroundColor = this.colors[this.scheduleEvent.color];
      }
      return this.eventBackgroundColor = this.colors.blue;
    },
    handleClickOnEvent() {
      const eventElement2 = document.getElementById(
        this.eventElementIdPrefix + this.scheduleEvent.id
      );
      this.$emit("event-was-clicked", {
        clickedEvent: this.scheduleEvent,
        eventElement: eventElement2
      });
    }
  }
});
const _hoisted_1$9 = ["id"];
const _hoisted_2$7 = {
  key: 1,
  class: "week-timeline__event"
};
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.scheduleEvent ? (openBlock(), createElementBlock("div", {
    key: 0,
    id: `${_ctx.eventElementIdPrefix}${_ctx.scheduleEvent.id}`,
    class: "week-timeline__event is-event",
    style: normalizeStyle({
      width: _ctx.eventWidth,
      color: _ctx.eventColor,
      backgroundColor: _ctx.eventBackgroundColor,
      zIndex: 1
    }),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClickOnEvent && _ctx.handleClickOnEvent(...args))
  }, toDisplayString(_ctx.scheduleEvent.title), 13, _hoisted_1$9)) : (openBlock(), createElementBlock("div", _hoisted_2$7));
}
var FullDayEvent = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9], ["__scopeId", "data-v-a74a4ce2"]]);
var WeekTimeline_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$8 = defineComponent({
  name: "WeekTimeline",
  components: { FullDayEvent },
  props: {
    days: {
      type: Array,
      required: true
    },
    time: {
      type: Object,
      required: true
    },
    fullDayEvents: {
      type: Array,
      default: () => []
    },
    config: {
      type: Object,
      required: true
    },
    mode: {
      type: String,
      required: true
    }
  },
  emits: ["event-was-clicked", "day-was-clicked"],
  data() {
    return {
      now: new Date()
    };
  },
  methods: {
    getDaysDate(day) {
      const { date } = this.time.getAllVariablesFromDateTimeString(
        day.dateTimeString
      );
      return date;
    }
  }
});
const _hoisted_1$8 = { class: "week-timeline" };
const _hoisted_2$6 = ["onClick"];
const _hoisted_3$4 = { class: "week-timeline__day-name" };
const _hoisted_4$4 = { class: "week-timeline__date" };
const _hoisted_5$3 = { class: "week-timeline__events" };
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FullDayEvent = resolveComponent("FullDayEvent");
  return openBlock(), createElementBlock("div", _hoisted_1$8, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.days, (day, dayIndex) => {
      return openBlock(), createElementBlock("div", {
        key: dayIndex,
        class: normalizeClass(["week-timeline__day", {
          "is-today": _ctx.time.getDateTimeStringFromDate(_ctx.now, "start") === day.dateTimeString
        }]),
        onClick: ($event) => _ctx.$emit("day-was-clicked", day.dateTimeString.substring(0, 10))
      }, [
        createElementVNode("div", _hoisted_3$4, toDisplayString(day.dayName.substring(0, 2).toUpperCase()), 1),
        createElementVNode("div", _hoisted_4$4, toDisplayString(_ctx.getDaysDate(day)), 1),
        createElementVNode("div", _hoisted_5$3, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(day.fullDayEvents, (event, key) => {
            return openBlock(), createElementBlock(Fragment, { key }, [
              key !== "date" ? (openBlock(), createBlock(_component_FullDayEvent, {
                key: 0,
                "schedule-event": typeof event === "object" ? event : null,
                config: _ctx.config,
                mode: _ctx.mode,
                onEventWasClicked: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("event-was-clicked", $event))
              }, null, 8, ["schedule-event", "config", "mode"])) : createCommentVNode("", true)
            ], 64);
          }), 128))
        ])
      ], 10, _hoisted_2$6);
    }), 128))
  ]);
}
var WeekTimeline = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8], ["__scopeId", "data-v-11113607"]]);
class EventPosition extends Time {
  positionFullDayEventsInWeek(weekStart, weekEnd, events) {
    const eventsWithJSDates = events.map((scheduleEvent) => {
      const { year: startYear, month: startMonth, date: startDate } = this.getAllVariablesFromDateTimeString(scheduleEvent.time.start);
      const { year: endYear, month: endMonth, date: endDate } = this.getAllVariablesFromDateTimeString(scheduleEvent.time.end);
      scheduleEvent.timeJS = {
        start: new Date(startYear, startMonth, startDate),
        end: new Date(endYear, endMonth, endDate)
      };
      return scheduleEvent;
    }).sort((a, b) => {
      if (a.time.start < b.time.start)
        return -1;
      if (a.time.start > b.time.start)
        return 1;
      return 0;
    });
    const allDatesOfWeek = this.getDatesBetweenTwoDates(weekStart, weekEnd);
    const week = allDatesOfWeek.map((d2) => ({ date: d2 }));
    for (const scheduleEvent of eventsWithJSDates) {
      for (const [dayIndex, day] of week.entries()) {
        const thisDayDateString = this.getDateStringFromDate(day.date);
        if (this.getDateStringFromDate(scheduleEvent.timeJS.start) <= thisDayDateString && this.getDateStringFromDate(scheduleEvent.timeJS.end) >= thisDayDateString) {
          let levelToStartOn = 1;
          while (typeof week[dayIndex][`level${levelToStartOn}`] !== "undefined") {
            levelToStartOn++;
          }
          let eventNDays = Math.ceil((scheduleEvent.timeJS.end.getTime() - day.date.getTime()) / this.MS_PER_DAY) + 1;
          const remainingDaysOfWeek = week.length - dayIndex;
          if (eventNDays > remainingDaysOfWeek)
            eventNDays = remainingDaysOfWeek;
          week[dayIndex][`level${levelToStartOn}`] = {
            ...scheduleEvent,
            nDays: eventNDays
          };
          for (let i = 1; i < eventNDays; i++) {
            week[dayIndex + i][`level${levelToStartOn}`] = "blocked";
          }
          break;
        }
      }
    }
    const weekWithSortedLevelsInDays = [];
    for (const day of week) {
      weekWithSortedLevelsInDays.push(Object.keys(day).sort().reduce(
        (obj, key) => {
          obj[key] = day[key];
          return obj;
        },
        {}
      ));
    }
    return weekWithSortedLevelsInDays;
  }
  positionFullDayEventsInMonth(calendarMonth, fullDayEvents) {
    const newMonth = [];
    const flatMonth = calendarMonth.flat();
    const monthMap = /* @__PURE__ */ new Map();
    flatMonth.forEach((day) => monthMap.set(day.dateTimeString.substring(0, 10), day));
    fullDayEvents = fullDayEvents.sort((a, b) => {
      if (a.time.start < b.time.start)
        return 1;
      if (a.time.start > b.time.start)
        return -1;
      return 0;
    });
    for (const fullDayEvent of fullDayEvents) {
      const { year: startYear, month: startMonth, date: startDate } = this.getAllVariablesFromDateTimeString(fullDayEvent.time.start);
      const { year: endYear, month: endMonth, date: endDate } = this.getAllVariablesFromDateTimeString(fullDayEvent.time.end);
      const allDatesOfEvent = this.getDatesBetweenTwoDates(
        new Date(startYear, startMonth, startDate),
        new Date(endYear, endMonth, endDate)
      );
      for (const date of allDatesOfEvent) {
        const dateString = this.getDateStringFromDate(date);
        const dateInMap = monthMap.get(dateString);
        if (dateInMap)
          monthMap.set(dateString, {
            ...dateInMap,
            events: [fullDayEvent, ...dateInMap.events]
          });
      }
    }
    let weekIterator = 0;
    monthMap.forEach((day) => {
      if (!newMonth.length)
        newMonth.push([day]);
      else if (newMonth[weekIterator] && newMonth[weekIterator].length < 7)
        newMonth[weekIterator].push(day);
      else if (newMonth[weekIterator] && newMonth[weekIterator].length === 7) {
        newMonth.push([day]);
        weekIterator++;
      }
    });
    return newMonth;
  }
}
const time = new Time();
class DragAndDrop {
  static eventCanBeDraggedFurther(event, direction, dayStart, dayEnd) {
    if (dayStart !== 0)
      dayStart = dayStart / 100;
    dayEnd = dayEnd / 100;
    if (direction === "forwards") {
      const lastHourBeforeEndOfDay = dayEnd - 1;
      const { hour: endHour } = time.getAllVariablesFromDateTimeString(event.time.end);
      const { minutes: endMinutes } = time.getAllVariablesFromDateTimeString(event.time.end);
      const { hour: startHour2 } = time.getAllVariablesFromDateTimeString(event.time.start);
      const { minutes: startMinutes2 } = time.getAllVariablesFromDateTimeString(event.time.start);
      return (endHour < lastHourBeforeEndOfDay || endHour === lastHourBeforeEndOfDay && endMinutes < 45) && (startHour2 < lastHourBeforeEndOfDay || startHour2 === lastHourBeforeEndOfDay && startMinutes2 < 45);
    }
    const { hour: startHour } = time.getAllVariablesFromDateTimeString(event.time.start);
    const { minutes: startMinutes } = time.getAllVariablesFromDateTimeString(event.time.start);
    return startHour > dayStart || startHour === dayStart && startMinutes >= 15;
  }
}
var DayEvent_vue_vue_type_style_index_0_scoped_true_lang = "";
const eventPositionHelper = new EventPosition();
const _sfc_main$7 = defineComponent({
  name: "DayEvent",
  components: {
    FontAwesomeIcon
  },
  props: {
    eventProp: {
      type: Object,
      required: true
    },
    time: {
      type: Object,
      required: true
    },
    config: {
      type: Object,
      required: true
    },
    dayInfo: {
      type: Object,
      required: true
    },
    mode: {
      type: String,
      required: true
    }
  },
  emits: ["event-was-clicked", "event-was-resized", "event-was-dragged"],
  data() {
    return {
      event: this.eventProp,
      icons: {
        clock: faClock$1,
        user: faUser$1,
        description: faComment$1,
        location: faMapMarkerAlt,
        topic: faQuestionCircle$1
      },
      showResizeElements: false,
      eventTransformValue: "initial",
      eventZIndexValue: "initial",
      dayElement: document.querySelector(".calendar-week__day"),
      resizingStartingPoint: void 0,
      resizingStartingPointEndOfTime: this.eventProp.time.end,
      resizingStartingPointStartOfTime: this.eventProp.time.start,
      resizingDirection: "",
      changeInQuarterHoursEventStart: 0,
      changeInQuarterHoursEventEnd: 0,
      isEditable: this.eventProp.isEditable || false,
      colors: EVENT_COLORS,
      eventColor: "#fff",
      eventBackgroundColor: "",
      isResizing: false,
      canDrag: false,
      clientYDragStart: null,
      clientXDragStart: null,
      changeInQuartersOnDrag: 0,
      changeInDaysOnDrag: 0,
      timeStartDragStart: this.eventProp.time.start,
      timeEndDragStart: this.eventProp.time.end
    };
  },
  computed: {
    getEventTime() {
      return this.time.getLocalizedTime(this.event.time.start) + " - " + this.time.getLocalizedTime(this.event.time.end);
    },
    timePointsInDay() {
      return this.time.DAY_END;
    },
    timePointsInOneMinute() {
      return 100 / 60;
    },
    getLeftRule() {
      if (!this.event.totalConcurrentEvents || !this.event.nOfPreviousConcurrentEvents)
        return 0;
      return this.event.nOfPreviousConcurrentEvents / this.event.totalConcurrentEvents * 100;
    },
    getWidthRule() {
      return 100 - this.getLeftRule;
    },
    getBorderRule() {
      if (!this.event.nOfPreviousConcurrentEvents)
        return "none";
      return "1px solid #fff";
    },
    eventIsLongerThan30Minutes() {
      const { hour: startHour, minutes: startMinutes } = this.time.getAllVariablesFromDateTimeString(this.event.time.start);
      const { hour: endHour, minutes: endMinutes } = this.time.getAllVariablesFromDateTimeString(this.event.time.end);
      const startDateMS = new Date(0, 0, 0, startHour, startMinutes).getTime();
      const endDateMS = new Date(0, 0, 0, endHour, endMinutes).getTime();
      return endDateMS - startDateMS >= 18e5;
    },
    hasDisabledDragAndDrop() {
      return !!(this.eventProp.disableDnD && this.eventProp.disableDnD.includes(this.mode));
    },
    hasDisabledResize() {
      return !!(this.eventProp.disableResize && this.eventProp.disableResize.includes(this.mode));
    },
    requiredStyles() {
      return {
        top: this.getPositionInDay(this.event.time.start),
        height: this.getLengthOfEvent(
          this.event.time.start,
          this.event.time.end
        ),
        left: this.getLeftRule + "%",
        width: this.getWidthRule + "%",
        transform: this.eventTransformValue,
        zIndex: this.eventZIndexValue
      };
    }
  },
  watch: {
    changeInQuarterHoursEventStart(newValue) {
      const { hour: dayStartHour, minutes: dayStartMinutes } = this.time.getHourAndMinutesFromTimePoints(this.time.DAY_START);
      const { year, month, date } = this.time.getAllVariablesFromDateTimeString(
        this.event.time.start
      );
      const startOfDayDateTimeString = this.time.getDateTimeStringFromDate(
        new Date(year, month, date, dayStartHour, dayStartMinutes)
      );
      const { hour: oldHour, minutes: oldMinutes } = this.time.getAllVariablesFromDateTimeString(
        this.resizingStartingPointStartOfTime
      );
      const oldStartOfTimeDate = new Date(
        year,
        month,
        date,
        oldHour,
        oldMinutes
      );
      const newStartOfTimeDate = new Date(
        oldStartOfTimeDate.getTime() + newValue * 15 * 6e4
      );
      const newStartOfTimeDateTimeString = this.time.getDateTimeStringFromDate(newStartOfTimeDate);
      if (newStartOfTimeDateTimeString < this.event.time.end && newStartOfTimeDateTimeString >= startOfDayDateTimeString)
        this.event.time.start = newStartOfTimeDateTimeString;
    },
    changeInQuarterHoursEventEnd(newValue) {
      const { hour: dayEndHour, minutes: dayEndMinutes } = this.time.getHourAndMinutesFromTimePoints(this.time.DAY_END);
      const { year, month, date } = this.time.getAllVariablesFromDateTimeString(
        this.event.time.start
      );
      const endOfDayDateTimeString = this.time.getDateTimeStringFromDate(
        new Date(year, month, date, dayEndHour, dayEndMinutes)
      );
      const { hour: oldHour, minutes: oldMinutes } = this.time.getAllVariablesFromDateTimeString(
        this.resizingStartingPointEndOfTime
      );
      const oldEndOfTimeDate = new Date(year, month, date, oldHour, oldMinutes);
      const newEndOfTimeDate = new Date(
        oldEndOfTimeDate.getTime() + newValue * 15 * 6e4
      );
      const newEndOfTimeDateTimeString = this.time.getDateTimeStringFromDate(newEndOfTimeDate);
      if (newEndOfTimeDateTimeString > this.event.time.start && newEndOfTimeDateTimeString <= endOfDayDateTimeString)
        this.event.time.end = newEndOfTimeDateTimeString;
    },
    changeInQuartersOnDrag(newValue) {
      const eventCanBeDraggedFurther = DragAndDrop.eventCanBeDraggedFurther(
        this.event,
        newValue <= -1 ? "backwards" : "forwards",
        this.time.DAY_START,
        this.time.DAY_END
      );
      if (!eventCanBeDraggedFurther)
        return;
      const newStart = this.time.addMinutesToDateTimeString(
        newValue * 15,
        this.timeStartDragStart
      );
      const newEnd = this.time.addMinutesToDateTimeString(
        newValue * 15,
        this.timeEndDragStart
      );
      this.event.time.start = this.event.time.start.replace(
        /\d{2}:\d{2}/,
        newStart.substring(11, 16)
      );
      this.event.time.end = this.event.time.end.replace(
        /\d{2}:\d{2}/,
        newEnd.substring(11, 16)
      );
    },
    changeInDaysOnDrag(newValue) {
      if (!this.dayElement)
        return;
      const upcomingDaysInWeek = this.dayInfo.daysTotalN - (this.dayInfo.thisDayIndex + 1);
      const previousDaysInWeek = 0 - this.dayInfo.thisDayIndex;
      if (newValue > upcomingDaysInWeek || newValue < previousDaysInWeek)
        return;
      const pixelsToTransform = newValue * this.dayElement.clientWidth;
      this.eventTransformValue = `translateX(${pixelsToTransform}px)`;
      const newStart = this.time.addDaysToDateTimeString(
        newValue,
        this.timeStartDragStart
      );
      const newEnd = this.time.addDaysToDateTimeString(
        newValue,
        this.timeEndDragStart
      );
      this.event.time.start = this.event.time.start.replace(
        /\d{4}-\d{2}-\d{2}/,
        newStart.substring(0, 10)
      );
      this.event.time.end = this.event.time.end.replace(
        /\d{4}-\d{2}-\d{2}/,
        newEnd.substring(0, 10)
      );
    }
  },
  mounted() {
    this.setColors();
  },
  methods: {
    getPositionInDay(dateTimeString) {
      return eventPositionHelper.getPercentageOfDayFromDateTimeString(
        dateTimeString,
        this.time.DAY_START,
        this.time.DAY_END
      ).toString() + "%";
    },
    getLengthOfEvent(start, end) {
      const startOfEvent = eventPositionHelper.getPercentageOfDayFromDateTimeString(
        start,
        this.time.DAY_START,
        this.time.DAY_END
      );
      const endOfEvent = eventPositionHelper.getPercentageOfDayFromDateTimeString(
        end,
        this.time.DAY_START,
        this.time.DAY_END
      );
      const length = endOfEvent - startOfEvent;
      return length + "%";
    },
    handleClickOnEvent(event) {
      const eventElement2 = this.getEventElementFromChildElement(event);
      if (!eventElement2)
        return;
      this.$emit("event-was-clicked", {
        clickedEvent: this.event,
        eventElement: eventElement2
      });
    },
    getEventElementFromChildElement(event) {
      const eventTarget = event.target;
      if (!eventTarget || typeof eventTarget.className.includes !== "function")
        return null;
      if (eventTarget.className.includes(".calendar-week__event"))
        return event.target;
      return eventTarget.closest(".calendar-week__event");
    },
    onMouseMove(event) {
      const eventsContainer = document.querySelector(".calendar-week__events");
      if (!eventsContainer)
        return;
      if (typeof this.resizingStartingPoint === "undefined")
        this.resizingStartingPoint = event.clientY;
      const cursorPositionY = event.clientY;
      if (!this.resizingStartingPoint)
        return;
      const nOfPixelsDistance = cursorPositionY - this.resizingStartingPoint;
      const eventsContainerHeight = eventsContainer.clientHeight;
      const percentageOfDayChanged = nOfPixelsDistance / eventsContainerHeight * 100;
      const changeInTimePoints = this.timePointsInDay / 100 * percentageOfDayChanged;
      const changeInMinutes = this.getMinutesFromTimePoints(changeInTimePoints);
      if (this.resizingDirection === "down") {
        this.changeInQuarterHoursEventEnd = Math.floor(changeInMinutes / 15);
      } else {
        this.changeInQuarterHoursEventStart = Math.floor(changeInMinutes / 15);
      }
    },
    onMouseUp() {
      this.stopResizing();
    },
    resizeEvent(direction) {
      this.isResizing = true;
      this.resizingDirection = direction;
      document.addEventListener("mousemove", this.onMouseMove);
      document.addEventListener("mouseup", this.onMouseUp);
    },
    stopResizing() {
      document.removeEventListener("mousemove", this.onMouseMove);
      document.removeEventListener("mouseup", this.onMouseUp);
      this.resetResizingValues();
      this.$emit("event-was-resized", this.event);
      this.isResizing = false;
    },
    resetResizingValues() {
      this.resizingStartingPoint = void 0;
      this.resizingStartingPointStartOfTime = this.eventProp.time.start;
      this.resizingStartingPointEndOfTime = this.eventProp.time.end;
      this.changeInQuarterHoursEventEnd = 0;
    },
    getMinutesFromTimePoints(timePoints) {
      return timePoints / this.timePointsInOneMinute;
    },
    setColors() {
      var _a, _b, _c;
      if (((_a = this.event) == null ? void 0 : _a.colorScheme) && ((_b = this.config.style) == null ? void 0 : _b.colorSchemes) && this.config.style.colorSchemes[this.event.colorScheme]) {
        this.eventColor = this.config.style.colorSchemes[this.event.colorScheme].color;
        return this.eventBackgroundColor = this.config.style.colorSchemes[this.event.colorScheme].backgroundColor;
      }
      if ((_c = this.event) == null ? void 0 : _c.color) {
        this.eventColor = "#fff";
        return this.eventBackgroundColor = this.colors[this.event.color];
      }
      return this.eventBackgroundColor = this.colors.blue;
    },
    handleMouseDown(mouseEvent) {
      if (!this.event.isEditable || this.hasDisabledDragAndDrop)
        return;
      this.canDrag = true;
      this.eventZIndexValue = 10;
      this.clientYDragStart = mouseEvent.clientY;
      this.clientXDragStart = mouseEvent.clientX;
      this.timeStartDragStart = this.event.time.start;
      this.timeEndDragStart = this.event.time.end;
      document.addEventListener("mousemove", this.handleDrag);
      document.addEventListener("mouseup", this.handleDragEnd);
    },
    handleDragEnd() {
      this.canDrag = false;
      this.eventZIndexValue = "initial";
      document.removeEventListener("mousemove", this.handleDrag);
      document.removeEventListener("mouseup", this.handleDragEnd);
      const dayChanged = this.changeInDaysOnDrag <= -1 || this.changeInDaysOnDrag > 0;
      const timeChanged = this.changeInQuartersOnDrag <= -1 || this.changeInQuartersOnDrag > 0;
      if (dayChanged || timeChanged)
        this.$emit("event-was-dragged", this.event);
    },
    handleDrag(mouseEvent) {
      if (this.isResizing || !this.canDrag || !this.clientYDragStart)
        return;
      this.handleVerticalDrag(mouseEvent);
      this.handleHorizontalDrag(mouseEvent);
    },
    handleVerticalDrag(mouseEvent) {
      const eventsContainer = document.querySelector(".calendar-week__events");
      if (!eventsContainer || !this.clientYDragStart)
        return;
      const nOfPixelsDistance = mouseEvent.clientY - this.clientYDragStart;
      const eventsContainerHeight = eventsContainer.clientHeight;
      const percentageOfDayChanged = nOfPixelsDistance / eventsContainerHeight * 100;
      const changeInTimePoints = this.timePointsInDay / 100 * percentageOfDayChanged;
      const changeInMinutes = this.getMinutesFromTimePoints(changeInTimePoints);
      this.changeInQuartersOnDrag = changeInMinutes < 0 ? Math.ceil(changeInMinutes / 15) : Math.floor(changeInMinutes / 15);
    },
    handleHorizontalDrag(mouseEvent) {
      if (!this.dayElement || !this.clientXDragStart)
        return;
      const dayWidth = this.dayElement.clientWidth;
      const changeInPixelsX = mouseEvent.clientX - this.clientXDragStart;
      this.changeInDaysOnDrag = changeInPixelsX < 0 ? Math.ceil(changeInPixelsX / dayWidth) : Math.floor(changeInPixelsX / dayWidth);
    }
  }
});
const _hoisted_1$7 = { class: "calendar-week__event-info-wrapper" };
const _hoisted_2$5 = { class: "calendar-week__event-row is-title" };
const _hoisted_3$3 = { class: "calendar-week__event-row is-time" };
const _hoisted_4$3 = {
  key: 1,
  class: "calendar-week__event-row is-location"
};
const _hoisted_5$2 = {
  key: 2,
  class: "calendar-week__event-row is-with"
};
const _hoisted_6$1 = {
  key: 3,
  class: "calendar-week__event-row is-topic"
};
const _hoisted_7$1 = {
  key: 4,
  class: "calendar-week__event-row is-description"
};
const _hoisted_8$1 = ["innerHTML"];
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
  return !_ctx.eventProp.isCustom ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(["calendar-week__event is-event", {
      "is-editable": _ctx.isEditable,
      "has-disabled-dnd": _ctx.hasDisabledDragAndDrop
    }]),
    style: normalizeStyle({
      ..._ctx.requiredStyles,
      border: _ctx.getBorderRule,
      color: _ctx.eventColor,
      backgroundColor: _ctx.eventBackgroundColor
    }),
    onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleClickOnEvent && _ctx.handleClickOnEvent(...args)),
    onMouseenter: _cache[3] || (_cache[3] = ($event) => _ctx.showResizeElements = _ctx.isEditable && !_ctx.hasDisabledResize),
    onMouseleave: _cache[4] || (_cache[4] = ($event) => _ctx.showResizeElements = false),
    onMousedown: _cache[5] || (_cache[5] = (...args) => _ctx.handleMouseDown && _ctx.handleMouseDown(...args))
  }, [
    createElementVNode("div", _hoisted_1$7, [
      _ctx.showResizeElements ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "calendar-week__event-resize calendar-week__event-resize-up",
        onMousedown: _cache[0] || (_cache[0] = ($event) => _ctx.resizeEvent("up"))
      }, null, 32)) : createCommentVNode("", true),
      createElementVNode("div", _hoisted_2$5, toDisplayString(_ctx.event.title), 1),
      createElementVNode("div", _hoisted_3$3, [
        createVNode(_component_font_awesome_icon, {
          icon: _ctx.icons.clock,
          class: "calendar-week__event-icon"
        }, null, 8, ["icon"]),
        createElementVNode("span", null, toDisplayString(_ctx.getEventTime), 1)
      ]),
      _ctx.event.location ? (openBlock(), createElementBlock("div", _hoisted_4$3, [
        createVNode(_component_font_awesome_icon, {
          icon: _ctx.icons.location,
          class: "calendar-week__event-icon"
        }, null, 8, ["icon"]),
        createElementVNode("span", null, toDisplayString(_ctx.event.location), 1)
      ])) : createCommentVNode("", true),
      _ctx.event.with ? (openBlock(), createElementBlock("div", _hoisted_5$2, [
        createVNode(_component_font_awesome_icon, {
          icon: _ctx.icons.user,
          class: "calendar-week__event-icon"
        }, null, 8, ["icon"]),
        createElementVNode("span", null, toDisplayString(_ctx.event.with), 1)
      ])) : createCommentVNode("", true),
      _ctx.event.topic ? (openBlock(), createElementBlock("div", _hoisted_6$1, [
        createVNode(_component_font_awesome_icon, {
          icon: _ctx.icons.topic,
          class: "calendar-week__event-icon"
        }, null, 8, ["icon"]),
        createElementVNode("span", null, toDisplayString(_ctx.event.topic), 1)
      ])) : createCommentVNode("", true),
      _ctx.event.description ? (openBlock(), createElementBlock("div", _hoisted_7$1, [
        createVNode(_component_font_awesome_icon, {
          icon: _ctx.icons.description,
          class: "calendar-week__event-icon"
        }, null, 8, ["icon"]),
        createElementVNode("p", {
          innerHTML: _ctx.event.description
        }, null, 8, _hoisted_8$1)
      ])) : createCommentVNode("", true),
      _ctx.eventIsLongerThan30Minutes ? (openBlock(), createElementBlock("div", {
        key: 5,
        class: "calendar-week__event-blend-out",
        style: normalizeStyle({
          backgroundImage: "linear-gradient(to bottom, transparent, " + _ctx.eventBackgroundColor + ")"
        })
      }, null, 4)) : createCommentVNode("", true),
      _ctx.showResizeElements ? (openBlock(), createElementBlock("div", {
        key: 6,
        class: "calendar-week__event-resize calendar-week__event-resize-down",
        onMousedown: _cache[1] || (_cache[1] = ($event) => _ctx.resizeEvent("down"))
      }, null, 32)) : createCommentVNode("", true)
    ])
  ], 38)) : (openBlock(), createElementBlock("div", {
    key: 1,
    style: normalizeStyle({
      ..._ctx.requiredStyles,
      border: _ctx.getBorderRule,
      color: _ctx.eventColor
    }),
    class: normalizeClass(["calendar-week__event is-event", {
      "is-editable": _ctx.isEditable,
      "has-disabled-dnd": _ctx.hasDisabledDragAndDrop
    }]),
    onClick: _cache[6] || (_cache[6] = (...args) => _ctx.handleClickOnEvent && _ctx.handleClickOnEvent(...args)),
    onMousedown: _cache[7] || (_cache[7] = (...args) => _ctx.handleMouseDown && _ctx.handleMouseDown(...args))
  }, [
    renderSlot(_ctx.$slots, "event", { eventData: _ctx.event }, void 0, true)
  ], 38));
}
var DayEvent = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7], ["__scopeId", "data-v-30561702"]]);
class EventConcurrency {
  sortEventsAccordingToStartOfTime(events) {
    function compare(a, b) {
      if (a.time.start < b.time.start) {
        return -1;
      }
      if (a.time.start > b.time.start) {
        return 1;
      }
      return 0;
    }
    return events.sort(compare);
  }
  calculateConcurrencyForEvents(events) {
    const updatedEvents = this.sortEventsAccordingToStartOfTime(events);
    if (!updatedEvents.length)
      return [];
    for (const [index, calendarEvent] of updatedEvents.entries()) {
      if (index === 0)
        continue;
      updatedEvents[index - 1];
      let iterator = 0;
      let nOfConcurrentEvents = 0;
      while (iterator < index) {
        if (updatedEvents[iterator].time.end > calendarEvent.time.start)
          nOfConcurrentEvents++;
        iterator++;
      }
      if (nOfConcurrentEvents)
        updatedEvents[index].nOfPreviousConcurrentEvents = nOfConcurrentEvents;
    }
    for (let index = updatedEvents.length - 1; index >= 0; index--) {
      let nOfUpcomingConcurrentEvents = 0;
      let iterator = updatedEvents.length - 1;
      while (iterator > index) {
        if (updatedEvents[iterator].time.start < updatedEvents[index].time.end) {
          nOfUpcomingConcurrentEvents++;
        }
        iterator--;
      }
      const nfOfPreviousEvents = updatedEvents[index].nOfPreviousConcurrentEvents || 0;
      updatedEvents[index].totalConcurrentEvents = nfOfPreviousEvents + nOfUpcomingConcurrentEvents + 1;
    }
    return events;
  }
}
class DayIntervals extends Time {
  constructor(intervalMinutes, dayStartDateTimeString, hoursPerDay = 24) {
    super();
    __publicField(this, "INTERVAL_MINUTES");
    __publicField(this, "DAY_START_DATE_TIME_STRING");
    __publicField(this, "HOURS_PER_DAY", 24);
    this.INTERVAL_MINUTES = intervalMinutes;
    this.DAY_START_DATE_TIME_STRING = dayStartDateTimeString;
    this.HOURS_PER_DAY = hoursPerDay;
  }
  getIntervals() {
    const intervals = [];
    const numberOfIntervalsInDay = this.HOURS_PER_DAY * (60 / this.INTERVAL_MINUTES);
    let iteratorDateTimeString = this.DAY_START_DATE_TIME_STRING;
    while (intervals.length < numberOfIntervalsInDay) {
      const intervalEnd = this.addMinutesToDateTimeString(this.INTERVAL_MINUTES, iteratorDateTimeString);
      intervals.push({
        intervalStart: iteratorDateTimeString,
        intervalEnd,
        hasBorder: intervalEnd.substring(14, 16) !== "00"
      });
      iteratorDateTimeString = intervalEnd;
    }
    return intervals;
  }
}
var Day_vue_vue_type_style_index_0_scoped_true_lang$1 = "";
const eventConcurrencyHelper = new EventConcurrency();
const _sfc_main$6 = defineComponent({
  name: "Day",
  components: { DayEvent },
  props: {
    day: {
      type: Object,
      required: true
    },
    time: {
      type: Object,
      required: true
    },
    config: {
      type: Object,
      required: true
    },
    dayInfo: {
      type: Object,
      required: true
    },
    mode: {
      type: String,
      required: true
    },
    dayIntervals: {
      type: Object,
      required: true
    }
  },
  emits: [
    "event-was-clicked",
    "event-was-resized",
    "event-was-dragged",
    "interval-was-clicked",
    "day-was-clicked"
  ],
  data() {
    return {
      events: [],
      intervals: []
    };
  },
  computed: {
    intervalStyles() {
      var _a;
      return ((_a = this.config.dayIntervals) == null ? void 0 : _a.intervalStyles) ? this.config.dayIntervals.intervalStyles : {};
    }
  },
  mounted() {
    this.calculateEventConcurrency();
    if (this.dayIntervals.displayClickableInterval)
      this.setClickableIntervals();
  },
  methods: {
    calculateEventConcurrency() {
      this.events = eventConcurrencyHelper.calculateConcurrencyForEvents(
        this.day.events
      );
    },
    handleEventWasResized(event) {
      this.$emit("event-was-resized", event);
      this.calculateEventConcurrency();
    },
    handleClickOnInterval(payload) {
      const { intervalStart, intervalEnd } = payload;
      this.$emit("interval-was-clicked", { intervalStart, intervalEnd });
    },
    setClickableIntervals() {
      let dayStartTimeString = this.day.dateTimeString;
      if (this.time.DAY_START !== 0) {
        const { hour: startHour } = this.time.getHourAndMinutesFromTimePoints(this.time.DAY_START);
        dayStartTimeString = this.time.setSegmentOfDateTimeString(dayStartTimeString, { hour: startHour });
      }
      this.intervals = new DayIntervals(
        this.dayIntervals.length || 60,
        dayStartTimeString,
        this.time.HOURS_PER_DAY
      ).getIntervals();
    }
  }
});
const _hoisted_1$6 = ["onClick"];
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DayEvent = resolveComponent("DayEvent");
  return openBlock(), createElementBlock("div", {
    class: "calendar-week__day",
    onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.$emit("day-was-clicked", _ctx.day.dateTimeString.substring(0, 10)), ["self"]))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.events, (event, eventIndex) => {
      return openBlock(), createBlock(_component_DayEvent, {
        key: eventIndex,
        "event-prop": event,
        day: _ctx.day,
        time: _ctx.time,
        config: _ctx.config,
        "day-info": _ctx.dayInfo,
        mode: _ctx.mode,
        onEventWasClicked: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("event-was-clicked", $event)),
        onEventWasDragged: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("event-was-dragged", $event)),
        onEventWasResized: _ctx.handleEventWasResized
      }, {
        event: withCtx((p) => [
          renderSlot(_ctx.$slots, "event", {
            eventData: p.eventData
          }, void 0, true)
        ]),
        _: 2
      }, 1032, ["event-prop", "day", "time", "config", "day-info", "mode", "onEventWasResized"]);
    }), 128)),
    _ctx.dayIntervals && _ctx.dayIntervals.displayClickableInterval ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.intervals, (interval2) => {
      return openBlock(), createElementBlock("div", {
        key: interval2.intervalStart,
        class: normalizeClass(["calendar-week__day-interval", { "has-border": interval2.hasBorder }]),
        style: normalizeStyle(_ctx.intervalStyles),
        onClick: ($event) => _ctx.handleClickOnInterval(interval2)
      }, toDisplayString(_ctx.time.getLocalizedTime(interval2.intervalStart)), 15, _hoisted_1$6);
    }), 128)) : createCommentVNode("", true)
  ]);
}
var Day$1 = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6], ["__scopeId", "data-v-34e5dd72"]]);
const calendarDomRectForVitest = {
  x: 8,
  y: 26,
  width: 903,
  height: 702,
  top: 26,
  right: 911,
  bottom: 728,
  left: 8
};
const EVENT_FLYOUT_WIDTH = 400;
class EventFlyoutPosition {
  calculateFlyoutPosition(eventElementDOMRect, flyoutDimensions, calendarDomRectParam = null) {
    const calendarDomRect = calendarDomRectParam || calendarDomRectForVitest;
    const spaceTop = eventElementDOMRect.top - calendarDomRect.top;
    const spaceRight = calendarDomRect.right - eventElementDOMRect.right;
    const spaceBottom = calendarDomRect.bottom - eventElementDOMRect.bottom;
    const spaceLeft = eventElementDOMRect.left - calendarDomRect.left;
    const flyoutNeededWidth = flyoutDimensions.width + 10;
    const topWhenSpaceToBottomIsNegative = spaceBottom < 0 ? calendarDomRect.bottom - flyoutDimensions.height - 10 : null;
    const topWhenSpaceTopIsNegative = spaceTop < 0 ? calendarDomRect.top + 10 : null;
    if (spaceBottom > flyoutDimensions.height && spaceRight > flyoutNeededWidth) {
      return {
        top: topWhenSpaceTopIsNegative ? topWhenSpaceTopIsNegative : Math.round(eventElementDOMRect.top),
        left: Math.round(eventElementDOMRect.right) + 10
      };
    }
    if (spaceTop > flyoutDimensions.height && spaceRight > flyoutNeededWidth) {
      return {
        top: topWhenSpaceToBottomIsNegative ? topWhenSpaceToBottomIsNegative : Math.round(eventElementDOMRect.bottom) - flyoutDimensions.height,
        left: Math.round(eventElementDOMRect.right) + 10
      };
    }
    if (spaceLeft > flyoutNeededWidth && spaceBottom > flyoutDimensions.height) {
      return {
        top: topWhenSpaceTopIsNegative ? topWhenSpaceTopIsNegative : eventElementDOMRect.top,
        left: Math.round(
          eventElementDOMRect.left - (flyoutDimensions.width + 10)
        )
      };
    }
    if (spaceLeft > flyoutNeededWidth && spaceTop > flyoutDimensions.height) {
      return {
        top: topWhenSpaceToBottomIsNegative ? topWhenSpaceToBottomIsNegative : Math.round(eventElementDOMRect.bottom - flyoutDimensions.height),
        left: Math.round(
          eventElementDOMRect.left - (flyoutDimensions.width + 10)
        )
      };
    }
    if (spaceBottom < flyoutDimensions.height) {
      return { top: calendarDomRect.bottom - flyoutDimensions.height, left: null };
    }
    return { top: eventElementDOMRect.top, left: null };
  }
}
/*!
 * Font Awesome Free 6.1.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2022 Fonticons, Inc.
 */
var faCircleQuestion = {
  prefix: "far",
  iconName: "circle-question",
  icon: [512, 512, [62108, "question-circle"], "f059", "M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 464c-114.7 0-208-93.31-208-208S141.3 48 256 48s208 93.31 208 208S370.7 464 256 464zM256 336c-18 0-32 14-32 32s13.1 32 32 32c17.1 0 32-14 32-32S273.1 336 256 336zM289.1 128h-51.1C199 128 168 159 168 198c0 13 11 24 24 24s24-11 24-24C216 186 225.1 176 237.1 176h51.1C301.1 176 312 186 312 198c0 8-4 14.1-11 18.1L244 251C236 256 232 264 232 272V288c0 13 11 24 24 24S280 301 280 288V286l45.1-28c21-13 34-36 34-60C360 159 329 128 289.1 128z"]
};
var faQuestionCircle = faCircleQuestion;
var faClock = {
  prefix: "far",
  iconName: "clock",
  icon: [512, 512, [128339, "clock-four"], "f017", "M232 120C232 106.7 242.7 96 256 96C269.3 96 280 106.7 280 120V243.2L365.3 300C376.3 307.4 379.3 322.3 371.1 333.3C364.6 344.3 349.7 347.3 338.7 339.1L242.7 275.1C236 271.5 232 264 232 255.1L232 120zM256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512C114.6 512 0 397.4 0 256C0 114.6 114.6 0 256 0zM48 256C48 370.9 141.1 464 256 464C370.9 464 464 370.9 464 256C464 141.1 370.9 48 256 48C141.1 48 48 141.1 48 256z"]
};
var faComment = {
  prefix: "far",
  iconName: "comment",
  icon: [512, 512, [61669, 128489], "f075", "M256 32C114.6 32 .0272 125.1 .0272 240c0 47.63 19.91 91.25 52.91 126.2c-14.88 39.5-45.87 72.88-46.37 73.25c-6.625 7-8.375 17.25-4.625 26C5.818 474.2 14.38 480 24 480c61.5 0 109.1-25.75 139.1-46.25C191.1 442.8 223.3 448 256 448c141.4 0 255.1-93.13 255.1-208S397.4 32 256 32zM256.1 400c-26.75 0-53.12-4.125-78.38-12.12l-22.75-7.125l-19.5 13.75c-14.25 10.12-33.88 21.38-57.5 29c7.375-12.12 14.37-25.75 19.88-40.25l10.62-28l-20.62-21.87C69.82 314.1 48.07 282.2 48.07 240c0-88.25 93.25-160 208-160s208 71.75 208 160S370.8 400 256.1 400z"]
};
var faPenToSquare = {
  prefix: "far",
  iconName: "pen-to-square",
  icon: [512, 512, ["edit"], "f044", "M373.1 24.97C401.2-3.147 446.8-3.147 474.9 24.97L487 37.09C515.1 65.21 515.1 110.8 487 138.9L289.8 336.2C281.1 344.8 270.4 351.1 258.6 354.5L158.6 383.1C150.2 385.5 141.2 383.1 135 376.1C128.9 370.8 126.5 361.8 128.9 353.4L157.5 253.4C160.9 241.6 167.2 230.9 175.8 222.2L373.1 24.97zM440.1 58.91C431.6 49.54 416.4 49.54 407 58.91L377.9 88L424 134.1L453.1 104.1C462.5 95.6 462.5 80.4 453.1 71.03L440.1 58.91zM203.7 266.6L186.9 325.1L245.4 308.3C249.4 307.2 252.9 305.1 255.8 302.2L390.1 168L344 121.9L209.8 256.2C206.9 259.1 204.8 262.6 203.7 266.6zM200 64C213.3 64 224 74.75 224 88C224 101.3 213.3 112 200 112H88C65.91 112 48 129.9 48 152V424C48 446.1 65.91 464 88 464H360C382.1 464 400 446.1 400 424V312C400 298.7 410.7 288 424 288C437.3 288 448 298.7 448 312V424C448 472.6 408.6 512 360 512H88C39.4 512 0 472.6 0 424V152C0 103.4 39.4 64 88 64H200z"]
};
var faEdit = faPenToSquare;
var faTrashCan = {
  prefix: "far",
  iconName: "trash-can",
  icon: [448, 512, [61460, "trash-alt"], "f2ed", "M160 400C160 408.8 152.8 416 144 416C135.2 416 128 408.8 128 400V192C128 183.2 135.2 176 144 176C152.8 176 160 183.2 160 192V400zM240 400C240 408.8 232.8 416 224 416C215.2 416 208 408.8 208 400V192C208 183.2 215.2 176 224 176C232.8 176 240 183.2 240 192V400zM320 400C320 408.8 312.8 416 304 416C295.2 416 288 408.8 288 400V192C288 183.2 295.2 176 304 176C312.8 176 320 183.2 320 192V400zM317.5 24.94L354.2 80H424C437.3 80 448 90.75 448 104C448 117.3 437.3 128 424 128H416V432C416 476.2 380.2 512 336 512H112C67.82 512 32 476.2 32 432V128H24C10.75 128 0 117.3 0 104C0 90.75 10.75 80 24 80H93.82L130.5 24.94C140.9 9.357 158.4 0 177.1 0H270.9C289.6 0 307.1 9.358 317.5 24.94H317.5zM151.5 80H296.5L277.5 51.56C276 49.34 273.5 48 270.9 48H177.1C174.5 48 171.1 49.34 170.5 51.56L151.5 80zM80 432C80 449.7 94.33 464 112 464H336C353.7 464 368 449.7 368 432V128H80V432z"]
};
var faTrashAlt = faTrashCan;
var faUser = {
  prefix: "far",
  iconName: "user",
  icon: [448, 512, [62144, 128100], "f007", "M272 304h-96C78.8 304 0 382.8 0 480c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32C448 382.8 369.2 304 272 304zM48.99 464C56.89 400.9 110.8 352 176 352h96c65.16 0 119.1 48.95 127 112H48.99zM224 256c70.69 0 128-57.31 128-128c0-70.69-57.31-128-128-128S96 57.31 96 128C96 198.7 153.3 256 224 256zM224 48c44.11 0 80 35.89 80 80c0 44.11-35.89 80-80 80S144 172.1 144 128C144 83.89 179.9 48 224 48z"]
};
var EventFlyout_vue_vue_type_style_index_0_scoped_true_lang = "";
const eventFlyoutPositionHelper = new EventFlyoutPosition();
const __default__$3 = defineComponent({
  name: "EventFlyout",
  components: {
    FontAwesomeIcon
  },
  props: {
    calendarEventProp: {
      type: Object,
      default: () => ({})
    },
    eventElement: {
      type: Object,
      default: null
    },
    time: {
      type: Object,
      required: true
    },
    config: {
      type: Object,
      required: true
    }
  },
  emits: ["hide", "edit-event", "delete-event"],
  data() {
    return {
      isVisible: false,
      top: 0,
      left: 0,
      icons: {
        clock: faClock,
        user: faUser,
        description: faComment,
        trash: faTrashAlt,
        edit: faEdit,
        times: faTimes,
        topic: faQuestionCircle,
        location: faMapMarkerAlt
      },
      calendarEvent: this.calendarEventProp,
      flyoutWidth: EVENT_FLYOUT_WIDTH + "px",
      colors: EVENT_COLORS
    };
  },
  computed: {
    getEventTime() {
      if (!this.calendarEvent || !this.calendarEvent.time)
        return null;
      if (DATE_TIME_STRING_FULL_DAY_PATTERN.test(this.calendarEvent.time.start)) {
        const startDate = this.getDateFromDateString(
          this.calendarEvent.time.start
        );
        const endDate = this.getDateFromDateString(this.calendarEvent.time.end);
        if (startDate === endDate)
          return startDate;
        return `${startDate} - ${endDate}`;
      }
      const dateString = this.getDateFromDateString(
        this.calendarEvent.time.start
      );
      const timeString = this.time.getLocalizedTime(this.calendarEvent.time.start) + " - " + this.time.getLocalizedTime(this.calendarEvent.time.end);
      return `${dateString} \u22C5 ${timeString}`;
    },
    eventFlyoutInlineStyles() {
      if (typeof this.top === "number" && !this.left) {
        return {
          top: this.top + "px",
          left: "50%",
          position: "fixed",
          transform: "translateX(-50%)"
        };
      }
      return {
        top: this.top + "px",
        left: this.left + "px",
        position: "fixed"
      };
    },
    isEditable() {
      var _a;
      return ((_a = this.calendarEventProp) == null ? void 0 : _a.isEditable) || false;
    },
    eventBackgroundColor() {
      var _a, _b, _c;
      if (((_a = this.calendarEvent) == null ? void 0 : _a.colorScheme) && ((_b = this.config.style) == null ? void 0 : _b.colorSchemes) && this.config.style.colorSchemes[this.calendarEvent.colorScheme]) {
        return this.config.style.colorSchemes[this.calendarEvent.colorScheme].backgroundColor;
      }
      return this.colors[((_c = this.calendarEvent) == null ? void 0 : _c.color) || "blue"];
    }
  },
  watch: {
    calendarEventProp: {
      deep: true,
      handler(value) {
        setTimeout(() => {
          this.calendarEvent = value;
          this.isVisible = !!value;
          this.$nextTick(() => this.setFlyoutPosition());
        }, 10);
      }
    }
  },
  mounted() {
    this.listenForClickOutside();
  },
  beforeUnmount() {
    document.removeEventListener("click", this.closeFlyoutOnClickOutside);
  },
  methods: {
    setFlyoutPosition() {
      var _a, _b;
      const calendar = (_a = this.eventElement) == null ? void 0 : _a.closest(".calendar-root");
      const flyout = document.querySelector(".event-flyout");
      if (!this.eventElement)
        return;
      const flyoutPosition = eventFlyoutPositionHelper.calculateFlyoutPosition(
        (_b = this.eventElement) == null ? void 0 : _b.getBoundingClientRect(),
        {
          height: (flyout == null ? void 0 : flyout.clientHeight) || 300,
          width: (flyout == null ? void 0 : flyout.clientWidth) || 0
        },
        calendar ? calendar.getBoundingClientRect() : null
      );
      this.top = typeof (flyoutPosition == null ? void 0 : flyoutPosition.top) === "number" ? flyoutPosition.top : null;
      this.left = typeof (flyoutPosition == null ? void 0 : flyoutPosition.left) === "number" ? flyoutPosition.left : null;
    },
    editEvent() {
      var _a;
      this.$emit("edit-event", (_a = this.calendarEvent) == null ? void 0 : _a.id);
      this.closeFlyout();
    },
    deleteEvent() {
      var _a;
      this.$emit("delete-event", (_a = this.calendarEvent) == null ? void 0 : _a.id);
      this.closeFlyout();
    },
    closeFlyout() {
      this.isVisible = false;
      setTimeout(() => {
        this.$emit("hide");
      }, 100);
    },
    getDateFromDateString(dateString) {
      const { year, month, date } = this.time.getAllVariablesFromDateTimeString(dateString);
      return new Date(year, month, date).toLocaleDateString(
        this.time.CALENDAR_LOCALE,
        {
          year: "numeric",
          month: "long",
          day: "numeric"
        }
      );
    },
    listenForClickOutside() {
      document.addEventListener("click", this.closeFlyoutOnClickOutside);
    },
    closeFlyoutOnClickOutside(e) {
      try {
        const flyout = document.querySelector(".event-flyout");
        if (!flyout || !this.isVisible)
          return;
        const isClickOutside = !flyout.contains(e.target);
        const isClickOnEvent = !!e.target.closest(".is-event");
        if (this.isVisible && isClickOutside && !isClickOnEvent)
          this.closeFlyout();
      } catch (err) {
        console.log(err);
      }
    }
  }
});
const __injectCSSVars__$3 = () => {
  useCssVars((_ctx) => ({
    "4afbc872": _ctx.flyoutWidth
  }));
};
const __setup__$3 = __default__$3.setup;
__default__$3.setup = __setup__$3 ? (props, ctx) => {
  __injectCSSVars__$3();
  return __setup__$3(props, ctx);
} : __injectCSSVars__$3;
const _sfc_main$5 = __default__$3;
const _hoisted_1$5 = {
  key: 0,
  class: "event-flyout__relative-wrapper"
};
const _hoisted_2$4 = { class: "event-flyout__menu" };
const _hoisted_3$2 = {
  key: 0,
  class: "event-flyout__menu-editable"
};
const _hoisted_4$2 = { class: "event-flyout__menu-close" };
const _hoisted_5$1 = {
  key: 0,
  class: "event-flyout__info-wrapper"
};
const _hoisted_6 = {
  key: 0,
  class: "event-flyout__row is-title"
};
const _hoisted_7 = {
  key: 1,
  class: "event-flyout__row is-time"
};
const _hoisted_8 = {
  key: 2,
  class: "event-flyout__row is-location"
};
const _hoisted_9 = {
  key: 3,
  class: "event-flyout__row"
};
const _hoisted_10 = {
  key: 4,
  class: "event-flyout__row"
};
const _hoisted_11 = {
  key: 5,
  class: "event-flyout__row"
};
const _hoisted_12 = ["innerHTML"];
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["event-flyout", { "is-visible": _ctx.isVisible, "is-not-editable": !_ctx.isEditable }]),
    style: normalizeStyle(_ctx.eventFlyoutInlineStyles)
  }, [
    !_ctx.config.eventDialog || !_ctx.config.eventDialog.isCustom ? (openBlock(), createElementBlock("div", _hoisted_1$5, [
      createElementVNode("div", _hoisted_2$4, [
        _ctx.isEditable ? (openBlock(), createElementBlock("span", _hoisted_3$2, [
          createVNode(_component_font_awesome_icon, {
            class: "event-flyout__menu-item is-edit-icon",
            icon: _ctx.icons.edit,
            onClick: _ctx.editEvent
          }, null, 8, ["icon", "onClick"]),
          createVNode(_component_font_awesome_icon, {
            class: "event-flyout__menu-item is-trash-icon",
            icon: _ctx.icons.trash,
            onClick: _ctx.deleteEvent
          }, null, 8, ["icon", "onClick"])
        ])) : createCommentVNode("", true),
        createElementVNode("span", _hoisted_4$2, [
          createVNode(_component_font_awesome_icon, {
            class: "event-flyout__menu-item is-times-icon",
            icon: _ctx.icons.times,
            onClick: _ctx.closeFlyout
          }, null, 8, ["icon", "onClick"])
        ])
      ]),
      _ctx.calendarEvent ? (openBlock(), createElementBlock("div", _hoisted_5$1, [
        _ctx.calendarEvent.title ? (openBlock(), createElementBlock("div", _hoisted_6, [
          createElementVNode("div", {
            class: "event-flyout__color-icon",
            style: normalizeStyle({ backgroundColor: _ctx.eventBackgroundColor })
          }, null, 4),
          createTextVNode(" " + toDisplayString(_ctx.calendarEvent.title), 1)
        ])) : createCommentVNode("", true),
        _ctx.calendarEvent.time ? (openBlock(), createElementBlock("div", _hoisted_7, toDisplayString(_ctx.getEventTime), 1)) : createCommentVNode("", true),
        _ctx.calendarEvent.location ? (openBlock(), createElementBlock("div", _hoisted_8, [
          createVNode(_component_font_awesome_icon, {
            icon: _ctx.icons.location
          }, null, 8, ["icon"]),
          createTextVNode(" " + toDisplayString(_ctx.calendarEvent.location), 1)
        ])) : createCommentVNode("", true),
        _ctx.calendarEvent.with ? (openBlock(), createElementBlock("div", _hoisted_9, [
          createVNode(_component_font_awesome_icon, {
            icon: _ctx.icons.user
          }, null, 8, ["icon"]),
          createTextVNode(" " + toDisplayString(_ctx.calendarEvent.with), 1)
        ])) : createCommentVNode("", true),
        _ctx.calendarEvent.topic ? (openBlock(), createElementBlock("div", _hoisted_10, [
          createVNode(_component_font_awesome_icon, {
            icon: _ctx.icons.topic,
            class: "calendar-week__event-icon"
          }, null, 8, ["icon"]),
          createTextVNode(" " + toDisplayString(_ctx.calendarEvent.topic), 1)
        ])) : createCommentVNode("", true),
        _ctx.calendarEvent.description ? (openBlock(), createElementBlock("div", _hoisted_11, [
          createVNode(_component_font_awesome_icon, {
            icon: _ctx.icons.description,
            class: "calendar-week__event-icon"
          }, null, 8, ["icon"]),
          createElementVNode("p", {
            innerHTML: _ctx.calendarEvent.description
          }, null, 8, _hoisted_12)
        ])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true)
    ])) : renderSlot(_ctx.$slots, "default", {
      key: 1,
      eventDialogData: _ctx.calendarEvent,
      closeEventDialog: _ctx.closeFlyout
    }, void 0, true)
  ], 6);
}
var EventFlyout = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5], ["__scopeId", "data-v-60f1899a"]]);
/*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function get(element) {
  return getComputedStyle(element);
}
function set(element, obj) {
  for (var key in obj) {
    var val = obj[key];
    if (typeof val === "number") {
      val = val + "px";
    }
    element.style[key] = val;
  }
  return element;
}
function div(className) {
  var div2 = document.createElement("div");
  div2.className = className;
  return div2;
}
var elMatches = typeof Element !== "undefined" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function matches(element, query) {
  if (!elMatches) {
    throw new Error("No element matching method supported");
  }
  return elMatches.call(element, query);
}
function remove(element) {
  if (element.remove) {
    element.remove();
  } else {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
}
function queryChildren(element, selector) {
  return Array.prototype.filter.call(
    element.children,
    function(child) {
      return matches(child, selector);
    }
  );
}
var cls = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(x) {
      return "ps__thumb-" + x;
    },
    rail: function(x) {
      return "ps__rail-" + x;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(x) {
      return "ps--active-" + x;
    },
    scrolling: function(x) {
      return "ps--scrolling-" + x;
    }
  }
};
var scrollingClassTimeout = { x: null, y: null };
function addScrollingClass(i, x) {
  var classList2 = i.element.classList;
  var className = cls.state.scrolling(x);
  if (classList2.contains(className)) {
    clearTimeout(scrollingClassTimeout[x]);
  } else {
    classList2.add(className);
  }
}
function removeScrollingClass(i, x) {
  scrollingClassTimeout[x] = setTimeout(
    function() {
      return i.isAlive && i.element.classList.remove(cls.state.scrolling(x));
    },
    i.settings.scrollingThreshold
  );
}
function setScrollingClassInstantly(i, x) {
  addScrollingClass(i, x);
  removeScrollingClass(i, x);
}
var EventElement = function EventElement2(element) {
  this.element = element;
  this.handlers = {};
};
var prototypeAccessors = { isEmpty: { configurable: true } };
EventElement.prototype.bind = function bind(eventName, handler) {
  if (typeof this.handlers[eventName] === "undefined") {
    this.handlers[eventName] = [];
  }
  this.handlers[eventName].push(handler);
  this.element.addEventListener(eventName, handler, false);
};
EventElement.prototype.unbind = function unbind(eventName, target) {
  var this$1$1 = this;
  this.handlers[eventName] = this.handlers[eventName].filter(function(handler) {
    if (target && handler !== target) {
      return true;
    }
    this$1$1.element.removeEventListener(eventName, handler, false);
    return false;
  });
};
EventElement.prototype.unbindAll = function unbindAll() {
  for (var name in this.handlers) {
    this.unbind(name);
  }
};
prototypeAccessors.isEmpty.get = function() {
  var this$1$1 = this;
  return Object.keys(this.handlers).every(
    function(key) {
      return this$1$1.handlers[key].length === 0;
    }
  );
};
Object.defineProperties(EventElement.prototype, prototypeAccessors);
var EventManager = function EventManager2() {
  this.eventElements = [];
};
EventManager.prototype.eventElement = function eventElement(element) {
  var ee = this.eventElements.filter(function(ee2) {
    return ee2.element === element;
  })[0];
  if (!ee) {
    ee = new EventElement(element);
    this.eventElements.push(ee);
  }
  return ee;
};
EventManager.prototype.bind = function bind2(element, eventName, handler) {
  this.eventElement(element).bind(eventName, handler);
};
EventManager.prototype.unbind = function unbind2(element, eventName, handler) {
  var ee = this.eventElement(element);
  ee.unbind(eventName, handler);
  if (ee.isEmpty) {
    this.eventElements.splice(this.eventElements.indexOf(ee), 1);
  }
};
EventManager.prototype.unbindAll = function unbindAll2() {
  this.eventElements.forEach(function(e) {
    return e.unbindAll();
  });
  this.eventElements = [];
};
EventManager.prototype.once = function once(element, eventName, handler) {
  var ee = this.eventElement(element);
  var onceHandler = function(evt) {
    ee.unbind(eventName, onceHandler);
    handler(evt);
  };
  ee.bind(eventName, onceHandler);
};
function createEvent(name) {
  if (typeof window.CustomEvent === "function") {
    return new CustomEvent(name);
  } else {
    var evt = document.createEvent("CustomEvent");
    evt.initCustomEvent(name, false, false, void 0);
    return evt;
  }
}
function processScrollDiff(i, axis, diff, useScrollingClass, forceFireReachEvent) {
  if (useScrollingClass === void 0)
    useScrollingClass = true;
  if (forceFireReachEvent === void 0)
    forceFireReachEvent = false;
  var fields;
  if (axis === "top") {
    fields = [
      "contentHeight",
      "containerHeight",
      "scrollTop",
      "y",
      "up",
      "down"
    ];
  } else if (axis === "left") {
    fields = [
      "contentWidth",
      "containerWidth",
      "scrollLeft",
      "x",
      "left",
      "right"
    ];
  } else {
    throw new Error("A proper axis should be provided");
  }
  processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent);
}
function processScrollDiff$1(i, diff, ref, useScrollingClass, forceFireReachEvent) {
  var contentHeight = ref[0];
  var containerHeight = ref[1];
  var scrollTop = ref[2];
  var y = ref[3];
  var up = ref[4];
  var down = ref[5];
  if (useScrollingClass === void 0)
    useScrollingClass = true;
  if (forceFireReachEvent === void 0)
    forceFireReachEvent = false;
  var element = i.element;
  i.reach[y] = null;
  if (element[scrollTop] < 1) {
    i.reach[y] = "start";
  }
  if (element[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {
    i.reach[y] = "end";
  }
  if (diff) {
    element.dispatchEvent(createEvent("ps-scroll-" + y));
    if (diff < 0) {
      element.dispatchEvent(createEvent("ps-scroll-" + up));
    } else if (diff > 0) {
      element.dispatchEvent(createEvent("ps-scroll-" + down));
    }
    if (useScrollingClass) {
      setScrollingClassInstantly(i, y);
    }
  }
  if (i.reach[y] && (diff || forceFireReachEvent)) {
    element.dispatchEvent(createEvent("ps-" + y + "-reach-" + i.reach[y]));
  }
}
function toInt(x) {
  return parseInt(x, 10) || 0;
}
function isEditable(el) {
  return matches(el, "input,[contenteditable]") || matches(el, "select,[contenteditable]") || matches(el, "textarea,[contenteditable]") || matches(el, "button,[contenteditable]");
}
function outerWidth(element) {
  var styles2 = get(element);
  return toInt(styles2.width) + toInt(styles2.paddingLeft) + toInt(styles2.paddingRight) + toInt(styles2.borderLeftWidth) + toInt(styles2.borderRightWidth);
}
var env = {
  isWebKit: typeof document !== "undefined" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window !== "undefined" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator !== "undefined" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator !== "undefined" && /Chrome/i.test(navigator && navigator.userAgent)
};
function updateGeometry(i) {
  var element = i.element;
  var roundedScrollTop = Math.floor(element.scrollTop);
  var rect = element.getBoundingClientRect();
  i.containerWidth = Math.round(rect.width);
  i.containerHeight = Math.round(rect.height);
  i.contentWidth = element.scrollWidth;
  i.contentHeight = element.scrollHeight;
  if (!element.contains(i.scrollbarXRail)) {
    queryChildren(element, cls.element.rail("x")).forEach(
      function(el) {
        return remove(el);
      }
    );
    element.appendChild(i.scrollbarXRail);
  }
  if (!element.contains(i.scrollbarYRail)) {
    queryChildren(element, cls.element.rail("y")).forEach(
      function(el) {
        return remove(el);
      }
    );
    element.appendChild(i.scrollbarYRail);
  }
  if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
    i.scrollbarXActive = true;
    i.railXWidth = i.containerWidth - i.railXMarginWidth;
    i.railXRatio = i.containerWidth / i.railXWidth;
    i.scrollbarXWidth = getThumbSize(
      i,
      toInt(i.railXWidth * i.containerWidth / i.contentWidth)
    );
    i.scrollbarXLeft = toInt(
      (i.negativeScrollAdjustment + element.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth)
    );
  } else {
    i.scrollbarXActive = false;
  }
  if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
    i.scrollbarYActive = true;
    i.railYHeight = i.containerHeight - i.railYMarginHeight;
    i.railYRatio = i.containerHeight / i.railYHeight;
    i.scrollbarYHeight = getThumbSize(
      i,
      toInt(i.railYHeight * i.containerHeight / i.contentHeight)
    );
    i.scrollbarYTop = toInt(
      roundedScrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight)
    );
  } else {
    i.scrollbarYActive = false;
  }
  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
  }
  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
  }
  updateCss(element, i);
  if (i.scrollbarXActive) {
    element.classList.add(cls.state.active("x"));
  } else {
    element.classList.remove(cls.state.active("x"));
    i.scrollbarXWidth = 0;
    i.scrollbarXLeft = 0;
    element.scrollLeft = i.isRtl === true ? i.contentWidth : 0;
  }
  if (i.scrollbarYActive) {
    element.classList.add(cls.state.active("y"));
  } else {
    element.classList.remove(cls.state.active("y"));
    i.scrollbarYHeight = 0;
    i.scrollbarYTop = 0;
    element.scrollTop = 0;
  }
}
function getThumbSize(i, thumbSize) {
  if (i.settings.minScrollbarLength) {
    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
  }
  if (i.settings.maxScrollbarLength) {
    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
  }
  return thumbSize;
}
function updateCss(element, i) {
  var xRailOffset = { width: i.railXWidth };
  var roundedScrollTop = Math.floor(element.scrollTop);
  if (i.isRtl) {
    xRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth - i.contentWidth;
  } else {
    xRailOffset.left = element.scrollLeft;
  }
  if (i.isScrollbarXUsingBottom) {
    xRailOffset.bottom = i.scrollbarXBottom - roundedScrollTop;
  } else {
    xRailOffset.top = i.scrollbarXTop + roundedScrollTop;
  }
  set(i.scrollbarXRail, xRailOffset);
  var yRailOffset = { top: roundedScrollTop, height: i.railYHeight };
  if (i.isScrollbarYUsingRight) {
    if (i.isRtl) {
      yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth - 9;
    } else {
      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
    }
  } else {
    if (i.isRtl) {
      yRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
    } else {
      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
    }
  }
  set(i.scrollbarYRail, yRailOffset);
  set(i.scrollbarX, {
    left: i.scrollbarXLeft,
    width: i.scrollbarXWidth - i.railBorderXWidth
  });
  set(i.scrollbarY, {
    top: i.scrollbarYTop,
    height: i.scrollbarYHeight - i.railBorderYWidth
  });
}
function clickRail(i) {
  i.element;
  i.event.bind(i.scrollbarY, "mousedown", function(e) {
    return e.stopPropagation();
  });
  i.event.bind(i.scrollbarYRail, "mousedown", function(e) {
    var positionTop = e.pageY - window.pageYOffset - i.scrollbarYRail.getBoundingClientRect().top;
    var direction = positionTop > i.scrollbarYTop ? 1 : -1;
    i.element.scrollTop += direction * i.containerHeight;
    updateGeometry(i);
    e.stopPropagation();
  });
  i.event.bind(i.scrollbarX, "mousedown", function(e) {
    return e.stopPropagation();
  });
  i.event.bind(i.scrollbarXRail, "mousedown", function(e) {
    var positionLeft = e.pageX - window.pageXOffset - i.scrollbarXRail.getBoundingClientRect().left;
    var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;
    i.element.scrollLeft += direction * i.containerWidth;
    updateGeometry(i);
    e.stopPropagation();
  });
}
function dragThumb(i) {
  bindMouseScrollHandler(i, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]);
  bindMouseScrollHandler(i, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]);
}
function bindMouseScrollHandler(i, ref) {
  var containerHeight = ref[0];
  var contentHeight = ref[1];
  var pageY = ref[2];
  var railYHeight = ref[3];
  var scrollbarY = ref[4];
  var scrollbarYHeight = ref[5];
  var scrollTop = ref[6];
  var y = ref[7];
  var scrollbarYRail = ref[8];
  var element = i.element;
  var startingScrollTop = null;
  var startingMousePageY = null;
  var scrollBy = null;
  function mouseMoveHandler(e) {
    if (e.touches && e.touches[0]) {
      e[pageY] = e.touches[0].pageY;
    }
    element[scrollTop] = startingScrollTop + scrollBy * (e[pageY] - startingMousePageY);
    addScrollingClass(i, y);
    updateGeometry(i);
    e.stopPropagation();
    if (e.type.startsWith("touch") && e.changedTouches.length > 1) {
      e.preventDefault();
    }
  }
  function mouseUpHandler() {
    removeScrollingClass(i, y);
    i[scrollbarYRail].classList.remove(cls.state.clicking);
    i.event.unbind(i.ownerDocument, "mousemove", mouseMoveHandler);
  }
  function bindMoves(e, touchMode) {
    startingScrollTop = element[scrollTop];
    if (touchMode && e.touches) {
      e[pageY] = e.touches[0].pageY;
    }
    startingMousePageY = e[pageY];
    scrollBy = (i[contentHeight] - i[containerHeight]) / (i[railYHeight] - i[scrollbarYHeight]);
    if (!touchMode) {
      i.event.bind(i.ownerDocument, "mousemove", mouseMoveHandler);
      i.event.once(i.ownerDocument, "mouseup", mouseUpHandler);
      e.preventDefault();
    } else {
      i.event.bind(i.ownerDocument, "touchmove", mouseMoveHandler);
    }
    i[scrollbarYRail].classList.add(cls.state.clicking);
    e.stopPropagation();
  }
  i.event.bind(i[scrollbarY], "mousedown", function(e) {
    bindMoves(e);
  });
  i.event.bind(i[scrollbarY], "touchstart", function(e) {
    bindMoves(e, true);
  });
}
function keyboard(i) {
  var element = i.element;
  var elementHovered = function() {
    return matches(element, ":hover");
  };
  var scrollbarFocused = function() {
    return matches(i.scrollbarX, ":focus") || matches(i.scrollbarY, ":focus");
  };
  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }
      if (scrollTop === 0 && deltaY > 0 || scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0) {
        return !i.settings.wheelPropagation;
      }
    }
    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }
      if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0) {
        return !i.settings.wheelPropagation;
      }
    }
    return true;
  }
  i.event.bind(i.ownerDocument, "keydown", function(e) {
    if (e.isDefaultPrevented && e.isDefaultPrevented() || e.defaultPrevented) {
      return;
    }
    if (!elementHovered() && !scrollbarFocused()) {
      return;
    }
    var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
    if (activeElement) {
      if (activeElement.tagName === "IFRAME") {
        activeElement = activeElement.contentDocument.activeElement;
      } else {
        while (activeElement.shadowRoot) {
          activeElement = activeElement.shadowRoot.activeElement;
        }
      }
      if (isEditable(activeElement)) {
        return;
      }
    }
    var deltaX = 0;
    var deltaY = 0;
    switch (e.which) {
      case 37:
        if (e.metaKey) {
          deltaX = -i.contentWidth;
        } else if (e.altKey) {
          deltaX = -i.containerWidth;
        } else {
          deltaX = -30;
        }
        break;
      case 38:
        if (e.metaKey) {
          deltaY = i.contentHeight;
        } else if (e.altKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = 30;
        }
        break;
      case 39:
        if (e.metaKey) {
          deltaX = i.contentWidth;
        } else if (e.altKey) {
          deltaX = i.containerWidth;
        } else {
          deltaX = 30;
        }
        break;
      case 40:
        if (e.metaKey) {
          deltaY = -i.contentHeight;
        } else if (e.altKey) {
          deltaY = -i.containerHeight;
        } else {
          deltaY = -30;
        }
        break;
      case 32:
        if (e.shiftKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = -i.containerHeight;
        }
        break;
      case 33:
        deltaY = i.containerHeight;
        break;
      case 34:
        deltaY = -i.containerHeight;
        break;
      case 36:
        deltaY = i.contentHeight;
        break;
      case 35:
        deltaY = -i.contentHeight;
        break;
      default:
        return;
    }
    if (i.settings.suppressScrollX && deltaX !== 0) {
      return;
    }
    if (i.settings.suppressScrollY && deltaY !== 0) {
      return;
    }
    element.scrollTop -= deltaY;
    element.scrollLeft += deltaX;
    updateGeometry(i);
    if (shouldPreventDefault(deltaX, deltaY)) {
      e.preventDefault();
    }
  });
}
function wheel(i) {
  var element = i.element;
  function shouldPreventDefault(deltaX, deltaY) {
    var roundedScrollTop = Math.floor(element.scrollTop);
    var isTop = element.scrollTop === 0;
    var isBottom = roundedScrollTop + element.offsetHeight === element.scrollHeight;
    var isLeft = element.scrollLeft === 0;
    var isRight = element.scrollLeft + element.offsetWidth === element.scrollWidth;
    var hitsBound;
    if (Math.abs(deltaY) > Math.abs(deltaX)) {
      hitsBound = isTop || isBottom;
    } else {
      hitsBound = isLeft || isRight;
    }
    return hitsBound ? !i.settings.wheelPropagation : true;
  }
  function getDeltaFromEvent(e) {
    var deltaX = e.deltaX;
    var deltaY = -1 * e.deltaY;
    if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
      deltaX = -1 * e.wheelDeltaX / 6;
      deltaY = e.wheelDeltaY / 6;
    }
    if (e.deltaMode && e.deltaMode === 1) {
      deltaX *= 10;
      deltaY *= 10;
    }
    if (deltaX !== deltaX && deltaY !== deltaY) {
      deltaX = 0;
      deltaY = e.wheelDelta;
    }
    if (e.shiftKey) {
      return [-deltaY, -deltaX];
    }
    return [deltaX, deltaY];
  }
  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!env.isWebKit && element.querySelector("select:focus")) {
      return true;
    }
    if (!element.contains(target)) {
      return false;
    }
    var cursor = target;
    while (cursor && cursor !== element) {
      if (cursor.classList.contains(cls.element.consuming)) {
        return true;
      }
      var style = get(cursor);
      if (deltaY && style.overflowY.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
        if (maxScrollTop > 0) {
          if (cursor.scrollTop > 0 && deltaY < 0 || cursor.scrollTop < maxScrollTop && deltaY > 0) {
            return true;
          }
        }
      }
      if (deltaX && style.overflowX.match(/(scroll|auto)/)) {
        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
        if (maxScrollLeft > 0) {
          if (cursor.scrollLeft > 0 && deltaX < 0 || cursor.scrollLeft < maxScrollLeft && deltaX > 0) {
            return true;
          }
        }
      }
      cursor = cursor.parentNode;
    }
    return false;
  }
  function mousewheelHandler(e) {
    var ref = getDeltaFromEvent(e);
    var deltaX = ref[0];
    var deltaY = ref[1];
    if (shouldBeConsumedByChild(e.target, deltaX, deltaY)) {
      return;
    }
    var shouldPrevent = false;
    if (!i.settings.useBothWheelAxes) {
      element.scrollTop -= deltaY * i.settings.wheelSpeed;
      element.scrollLeft += deltaX * i.settings.wheelSpeed;
    } else if (i.scrollbarYActive && !i.scrollbarXActive) {
      if (deltaY) {
        element.scrollTop -= deltaY * i.settings.wheelSpeed;
      } else {
        element.scrollTop += deltaX * i.settings.wheelSpeed;
      }
      shouldPrevent = true;
    } else if (i.scrollbarXActive && !i.scrollbarYActive) {
      if (deltaX) {
        element.scrollLeft += deltaX * i.settings.wheelSpeed;
      } else {
        element.scrollLeft -= deltaY * i.settings.wheelSpeed;
      }
      shouldPrevent = true;
    }
    updateGeometry(i);
    shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
    if (shouldPrevent && !e.ctrlKey) {
      e.stopPropagation();
      e.preventDefault();
    }
  }
  if (typeof window.onwheel !== "undefined") {
    i.event.bind(element, "wheel", mousewheelHandler);
  } else if (typeof window.onmousewheel !== "undefined") {
    i.event.bind(element, "mousewheel", mousewheelHandler);
  }
}
function touch(i) {
  if (!env.supportsTouch && !env.supportsIePointer) {
    return;
  }
  var element = i.element;
  function shouldPrevent(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    var scrollLeft = element.scrollLeft;
    var magnitudeX = Math.abs(deltaX);
    var magnitudeY = Math.abs(deltaY);
    if (magnitudeY > magnitudeX) {
      if (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight || deltaY > 0 && scrollTop === 0) {
        return window.scrollY === 0 && deltaY > 0 && env.isChrome;
      }
    } else if (magnitudeX > magnitudeY) {
      if (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth || deltaX > 0 && scrollLeft === 0) {
        return true;
      }
    }
    return true;
  }
  function applyTouchMove(differenceX, differenceY) {
    element.scrollTop -= differenceY;
    element.scrollLeft -= differenceX;
    updateGeometry(i);
  }
  var startOffset = {};
  var startTime = 0;
  var speed = {};
  var easingLoop = null;
  function getTouch(e) {
    if (e.targetTouches) {
      return e.targetTouches[0];
    } else {
      return e;
    }
  }
  function shouldHandle(e) {
    if (e.pointerType && e.pointerType === "pen" && e.buttons === 0) {
      return false;
    }
    if (e.targetTouches && e.targetTouches.length === 1) {
      return true;
    }
    if (e.pointerType && e.pointerType !== "mouse" && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
      return true;
    }
    return false;
  }
  function touchStart(e) {
    if (!shouldHandle(e)) {
      return;
    }
    var touch2 = getTouch(e);
    startOffset.pageX = touch2.pageX;
    startOffset.pageY = touch2.pageY;
    startTime = new Date().getTime();
    if (easingLoop !== null) {
      clearInterval(easingLoop);
    }
  }
  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!element.contains(target)) {
      return false;
    }
    var cursor = target;
    while (cursor && cursor !== element) {
      if (cursor.classList.contains(cls.element.consuming)) {
        return true;
      }
      var style = get(cursor);
      if (deltaY && style.overflowY.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
        if (maxScrollTop > 0) {
          if (cursor.scrollTop > 0 && deltaY < 0 || cursor.scrollTop < maxScrollTop && deltaY > 0) {
            return true;
          }
        }
      }
      if (deltaX && style.overflowX.match(/(scroll|auto)/)) {
        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
        if (maxScrollLeft > 0) {
          if (cursor.scrollLeft > 0 && deltaX < 0 || cursor.scrollLeft < maxScrollLeft && deltaX > 0) {
            return true;
          }
        }
      }
      cursor = cursor.parentNode;
    }
    return false;
  }
  function touchMove(e) {
    if (shouldHandle(e)) {
      var touch2 = getTouch(e);
      var currentOffset = { pageX: touch2.pageX, pageY: touch2.pageY };
      var differenceX = currentOffset.pageX - startOffset.pageX;
      var differenceY = currentOffset.pageY - startOffset.pageY;
      if (shouldBeConsumedByChild(e.target, differenceX, differenceY)) {
        return;
      }
      applyTouchMove(differenceX, differenceY);
      startOffset = currentOffset;
      var currentTime = new Date().getTime();
      var timeGap = currentTime - startTime;
      if (timeGap > 0) {
        speed.x = differenceX / timeGap;
        speed.y = differenceY / timeGap;
        startTime = currentTime;
      }
      if (shouldPrevent(differenceX, differenceY)) {
        e.preventDefault();
      }
    }
  }
  function touchEnd() {
    if (i.settings.swipeEasing) {
      clearInterval(easingLoop);
      easingLoop = setInterval(function() {
        if (i.isInitialized) {
          clearInterval(easingLoop);
          return;
        }
        if (!speed.x && !speed.y) {
          clearInterval(easingLoop);
          return;
        }
        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
          clearInterval(easingLoop);
          return;
        }
        if (!i.element) {
          clearInterval(easingLoop);
          return;
        }
        applyTouchMove(speed.x * 30, speed.y * 30);
        speed.x *= 0.8;
        speed.y *= 0.8;
      }, 10);
    }
  }
  if (env.supportsTouch) {
    i.event.bind(element, "touchstart", touchStart);
    i.event.bind(element, "touchmove", touchMove);
    i.event.bind(element, "touchend", touchEnd);
  } else if (env.supportsIePointer) {
    if (window.PointerEvent) {
      i.event.bind(element, "pointerdown", touchStart);
      i.event.bind(element, "pointermove", touchMove);
      i.event.bind(element, "pointerup", touchEnd);
    } else if (window.MSPointerEvent) {
      i.event.bind(element, "MSPointerDown", touchStart);
      i.event.bind(element, "MSPointerMove", touchMove);
      i.event.bind(element, "MSPointerUp", touchEnd);
    }
  }
}
var defaultSettings = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: false,
    suppressScrollY: false,
    swipeEasing: true,
    useBothWheelAxes: false,
    wheelPropagation: true,
    wheelSpeed: 1
  };
};
var handlers = {
  "click-rail": clickRail,
  "drag-thumb": dragThumb,
  keyboard,
  wheel,
  touch
};
var PerfectScrollbar = function PerfectScrollbar2(element, userSettings) {
  var this$1$1 = this;
  if (userSettings === void 0)
    userSettings = {};
  if (typeof element === "string") {
    element = document.querySelector(element);
  }
  if (!element || !element.nodeName) {
    throw new Error("no element is specified to initialize PerfectScrollbar");
  }
  this.element = element;
  element.classList.add(cls.main);
  this.settings = defaultSettings();
  for (var key in userSettings) {
    this.settings[key] = userSettings[key];
  }
  this.containerWidth = null;
  this.containerHeight = null;
  this.contentWidth = null;
  this.contentHeight = null;
  var focus = function() {
    return element.classList.add(cls.state.focus);
  };
  var blur = function() {
    return element.classList.remove(cls.state.focus);
  };
  this.isRtl = get(element).direction === "rtl";
  if (this.isRtl === true) {
    element.classList.add(cls.rtl);
  }
  this.isNegativeScroll = function() {
    var originalScrollLeft = element.scrollLeft;
    var result = null;
    element.scrollLeft = -1;
    result = element.scrollLeft < 0;
    element.scrollLeft = originalScrollLeft;
    return result;
  }();
  this.negativeScrollAdjustment = this.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
  this.event = new EventManager();
  this.ownerDocument = element.ownerDocument || document;
  this.scrollbarXRail = div(cls.element.rail("x"));
  element.appendChild(this.scrollbarXRail);
  this.scrollbarX = div(cls.element.thumb("x"));
  this.scrollbarXRail.appendChild(this.scrollbarX);
  this.scrollbarX.setAttribute("tabindex", 0);
  this.event.bind(this.scrollbarX, "focus", focus);
  this.event.bind(this.scrollbarX, "blur", blur);
  this.scrollbarXActive = null;
  this.scrollbarXWidth = null;
  this.scrollbarXLeft = null;
  var railXStyle = get(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);
  if (isNaN(this.scrollbarXBottom)) {
    this.isScrollbarXUsingBottom = false;
    this.scrollbarXTop = toInt(railXStyle.top);
  } else {
    this.isScrollbarXUsingBottom = true;
  }
  this.railBorderXWidth = toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);
  set(this.scrollbarXRail, { display: "block" });
  this.railXMarginWidth = toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);
  set(this.scrollbarXRail, { display: "" });
  this.railXWidth = null;
  this.railXRatio = null;
  this.scrollbarYRail = div(cls.element.rail("y"));
  element.appendChild(this.scrollbarYRail);
  this.scrollbarY = div(cls.element.thumb("y"));
  this.scrollbarYRail.appendChild(this.scrollbarY);
  this.scrollbarY.setAttribute("tabindex", 0);
  this.event.bind(this.scrollbarY, "focus", focus);
  this.event.bind(this.scrollbarY, "blur", blur);
  this.scrollbarYActive = null;
  this.scrollbarYHeight = null;
  this.scrollbarYTop = null;
  var railYStyle = get(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(railYStyle.right, 10);
  if (isNaN(this.scrollbarYRight)) {
    this.isScrollbarYUsingRight = false;
    this.scrollbarYLeft = toInt(railYStyle.left);
  } else {
    this.isScrollbarYUsingRight = true;
  }
  this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;
  this.railBorderYWidth = toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);
  set(this.scrollbarYRail, { display: "block" });
  this.railYMarginHeight = toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);
  set(this.scrollbarYRail, { display: "" });
  this.railYHeight = null;
  this.railYRatio = null;
  this.reach = {
    x: element.scrollLeft <= 0 ? "start" : element.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: element.scrollTop <= 0 ? "start" : element.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  };
  this.isAlive = true;
  this.settings.handlers.forEach(function(handlerName) {
    return handlers[handlerName](this$1$1);
  });
  this.lastScrollTop = Math.floor(element.scrollTop);
  this.lastScrollLeft = element.scrollLeft;
  this.event.bind(this.element, "scroll", function(e) {
    return this$1$1.onScroll(e);
  });
  updateGeometry(this);
};
PerfectScrollbar.prototype.update = function update() {
  if (!this.isAlive) {
    return;
  }
  this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0;
  set(this.scrollbarXRail, { display: "block" });
  set(this.scrollbarYRail, { display: "block" });
  this.railXMarginWidth = toInt(get(this.scrollbarXRail).marginLeft) + toInt(get(this.scrollbarXRail).marginRight);
  this.railYMarginHeight = toInt(get(this.scrollbarYRail).marginTop) + toInt(get(this.scrollbarYRail).marginBottom);
  set(this.scrollbarXRail, { display: "none" });
  set(this.scrollbarYRail, { display: "none" });
  updateGeometry(this);
  processScrollDiff(this, "top", 0, false, true);
  processScrollDiff(this, "left", 0, false, true);
  set(this.scrollbarXRail, { display: "" });
  set(this.scrollbarYRail, { display: "" });
};
PerfectScrollbar.prototype.onScroll = function onScroll(e) {
  if (!this.isAlive) {
    return;
  }
  updateGeometry(this);
  processScrollDiff(this, "top", this.element.scrollTop - this.lastScrollTop);
  processScrollDiff(
    this,
    "left",
    this.element.scrollLeft - this.lastScrollLeft
  );
  this.lastScrollTop = Math.floor(this.element.scrollTop);
  this.lastScrollLeft = this.element.scrollLeft;
};
PerfectScrollbar.prototype.destroy = function destroy() {
  if (!this.isAlive) {
    return;
  }
  this.event.unbindAll();
  remove(this.scrollbarX);
  remove(this.scrollbarY);
  remove(this.scrollbarXRail);
  remove(this.scrollbarYRail);
  this.removePsClasses();
  this.element = null;
  this.scrollbarX = null;
  this.scrollbarY = null;
  this.scrollbarXRail = null;
  this.scrollbarYRail = null;
  this.isAlive = false;
};
PerfectScrollbar.prototype.removePsClasses = function removePsClasses() {
  this.element.className = this.element.className.split(" ").filter(function(name) {
    return !name.match(/^ps([-_].+|)$/);
  }).join(" ");
};
var Week_vue_vue_type_style_index_0_scoped_true_lang = "";
const eventPosition = new EventPosition();
const __default__$2 = defineComponent({
  name: "Week",
  components: {
    Day: Day$1,
    WeekTimeline,
    DayTimeline,
    EventFlyout
  },
  props: {
    config: {
      type: Object,
      required: true
    },
    eventsProp: {
      type: Array,
      default: () => []
    },
    period: {
      type: Object,
      required: true
    },
    modeProp: {
      type: String,
      default: "week"
    },
    time: {
      type: Object,
      required: true
    }
  },
  emits: [
    "event-was-clicked",
    "event-was-resized",
    "event-was-dragged",
    "edit-event",
    "delete-event",
    "interval-was-clicked",
    "day-was-clicked"
  ],
  data() {
    var _a;
    return {
      days: [],
      mode: this.modeProp,
      selectedEvent: null,
      selectedEventElement: null,
      events: this.eventsProp,
      fullDayEvents: [],
      weekVersion: 0,
      dayIntervals: {
        length: 60,
        height: 66
      },
      weekHeight: "1584px",
      scrollbar: null,
      currentTimePercentage: 0,
      showCurrentTime: !!((_a = this.config) == null ? void 0 : _a.showCurrentTime)
    };
  },
  computed: {
    hasCustomCurrentTimeSlot() {
      const hasSlotContent = (slot) => {
        if (!slot)
          return false;
        return slot().some((vnode) => {
          if (vnode.type === Comment)
            return false;
          if (Array.isArray(vnode.children) && !vnode.children.length)
            return false;
          return vnode.type !== Text || typeof vnode.children === "string" && vnode.children.trim() !== "";
        });
      };
      return hasSlotContent(this.$slots.customCurrentTime);
    },
    nDays() {
      var _a, _b;
      return ((_b = (_a = this.config) == null ? void 0 : _a.week) == null ? void 0 : _b.nDays) || 7;
    }
  },
  watch: {
    period: {
      deep: true,
      handler() {
        this.setInitialEvents(this.mode);
      }
    },
    modeProp: {
      deep: true,
      handler(value) {
        this.mode = value;
        this.setInitialEvents(value);
      }
    }
  },
  mounted() {
    var _a;
    this.setDayIntervals();
    this.filterOutFullDayEvents();
    this.setInitialEvents(this.modeProp);
    this.scrollOnMount();
    this.initScrollbar();
    if (((_a = this.config) == null ? void 0 : _a.showCurrentTime) || this.hasCustomCurrentTimeSlot)
      this.setCurrentTime();
  },
  methods: {
    initScrollbar(elapsedMs = 0) {
      const el = document.querySelector(".calendar-week__wrapper");
      if (elapsedMs > 3e3)
        return;
      if (!el)
        this.initScrollbar(elapsedMs + 50);
      else {
        this.scrollbar = new PerfectScrollbar(el);
        this.scrollbar.update();
      }
    },
    filterOutFullDayEvents() {
      const fullDayEvents = [];
      const allOtherEvents = [];
      for (const scheduleEvent of this.events) {
        if (scheduleEvent.time.start.match(DATE_TIME_STRING_PATTERN)) {
          allOtherEvents.push(scheduleEvent);
        } else if (scheduleEvent.time.start.match(DATE_TIME_STRING_FULL_DAY_PATTERN)) {
          fullDayEvents.push(scheduleEvent);
        }
      }
      const weekEndDate = this.nDays === 5 ? new Date(
        this.period.end.getFullYear(),
        this.period.end.getMonth(),
        this.period.end.getDate() - 2
      ) : this.period.end;
      this.fullDayEvents = fullDayEvents.length ? eventPosition.positionFullDayEventsInWeek(
        this.period.start,
        weekEndDate,
        fullDayEvents
      ) : [];
      this.events = allOtherEvents;
    },
    setDays() {
      const days = this.time.getCalendarWeekDateObjects(this.period.start).map((day) => {
        const dayName = this.time.getLocalizedNameOfWeekday(day, "long");
        const dateTimeString = this.time.getDateTimeStringFromDate(
          day,
          "start"
        );
        const events = this.events.filter((event) => {
          const eventIsInDay = event.time.start.substring(0, 11) === dateTimeString.substring(0, 11);
          let eventIsInDayBoundaries = true;
          if (this.time.HOURS_PER_DAY !== 24) {
            const { hour: dayStartHour } = this.time.getHourAndMinutesFromTimePoints(this.time.DAY_START);
            const { hour: dayEndHour } = this.time.getHourAndMinutesFromTimePoints(this.time.DAY_END);
            const { hour: eventStartHour } = this.time.getAllVariablesFromDateTimeString(event.time.start);
            eventIsInDayBoundaries = eventStartHour >= dayStartHour && eventStartHour < dayEndHour;
          }
          return eventIsInDay && eventIsInDayBoundaries;
        });
        return { dayName, dateTimeString, events };
      });
      if (this.nDays === 5 && this.time.FIRST_DAY_OF_WEEK === "monday") {
        days.splice(5, 2);
        this.fullDayEvents.splice(5, 2);
      } else if (this.nDays === 5 && this.time.FIRST_DAY_OF_WEEK === "sunday") {
        days.splice(6, 1);
        this.fullDayEvents.splice(6, 1);
        days.splice(0, 1);
        this.fullDayEvents.splice(0, 1);
      }
      this.days = days;
    },
    mergeFullDayEventsIntoDays() {
      for (const [dayIndex] of this.days.entries()) {
        this.days[dayIndex].fullDayEvents = this.fullDayEvents[dayIndex];
      }
    },
    setDay() {
      const dayDateTimeString = this.time.getDateTimeStringFromDate(
        this.period.selectedDate
      );
      this.days = [
        {
          dayName: new Date(this.period.selectedDate).toLocaleDateString(
            this.time.CALENDAR_LOCALE,
            { weekday: "long" }
          ),
          dateTimeString: this.time.getDateTimeStringFromDate(
            this.period.selectedDate,
            "start"
          ),
          events: this.events.filter((event) => {
            return event.time.start.substring(0, 11) === dayDateTimeString.substring(0, 11);
          })
        }
      ];
      if (!this.fullDayEvents.length)
        return;
      for (const day of this.fullDayEvents) {
        const dayDateString = this.time.getDateTimeStringFromDate(day.date);
        if (dayDateString.substring(0, 11) === dayDateTimeString.substring(0, 11)) {
          this.fullDayEvents = [day];
          return;
        }
      }
    },
    setInitialEvents(mode) {
      if (mode === "day")
        this.setDay();
      if (mode === "week")
        this.setDays();
      this.mergeFullDayEventsIntoDays();
    },
    handleClickOnEvent(event) {
      this.$emit("event-was-clicked", event);
      this.selectedEventElement = event.eventElement;
      this.selectedEvent = event.clickedEvent;
    },
    handleEventWasDragged(event) {
      const cleanedUpEvent = event;
      delete cleanedUpEvent.totalConcurrentEvents;
      delete cleanedUpEvent.nOfPreviousConcurrentEvents;
      const filteredEvents = this.events.filter((e) => e.id !== event.id);
      this.events = [
        cleanedUpEvent,
        ...filteredEvents.map((e) => {
          delete e.nOfPreviousConcurrentEvents;
          delete e.totalConcurrentEvents;
          return e;
        })
      ];
      this.setInitialEvents(this.mode);
      this.weekVersion = this.weekVersion + 1;
      this.$emit("event-was-dragged", event);
    },
    scrollOnMount() {
      if (this.time.HOURS_PER_DAY !== 24)
        return;
      const weekWrapper = document.querySelector(".calendar-week__wrapper");
      if (!weekWrapper)
        return;
      this.$nextTick(() => {
        var _a;
        const weekHeight = +this.weekHeight.split("p")[0];
        const oneHourInPixel = weekHeight / this.time.HOURS_PER_DAY;
        const hourToScrollTo = typeof ((_a = this.config.week) == null ? void 0 : _a.scrollToHour) === "number" ? this.config.week.scrollToHour : 8;
        const desiredNumberOfPixelsToScroll = oneHourInPixel * hourToScrollTo;
        weekWrapper.scroll(0, desiredNumberOfPixelsToScroll - 10);
      });
    },
    setDayIntervals() {
      if (this.config.dayIntervals) {
        for (const [key, value] of Object.entries(this.config.dayIntervals)) {
          this.dayIntervals[key] = value;
        }
      }
      this.setWeekHeightBasedOnIntervals();
    },
    setWeekHeightBasedOnIntervals() {
      if (![15, 30, 60].includes(this.dayIntervals.length)) {
        this.dayIntervals.length = 60;
        this.dayIntervals.height = 66;
        console.warn(
          "The dayIntervals configuration is faulty. It has been reset to default values."
        );
      }
      let intervalMultiplier = 1;
      if (this.dayIntervals.length === 15)
        intervalMultiplier = 4;
      if (this.dayIntervals.length === 30)
        intervalMultiplier = 2;
      this.weekHeight = this.dayIntervals.height * intervalMultiplier * this.time.HOURS_PER_DAY + "px";
    },
    setCurrentTime() {
      const setTime = () => {
        const nowString = this.time.getDateTimeStringFromDate(new Date());
        const currentTimePercentage = this.time.getPercentageOfDayFromDateTimeString(nowString, this.time.DAY_START, this.time.DAY_END);
        if (currentTimePercentage < 0 || currentTimePercentage > 100)
          return this.showCurrentTime = false;
        this.showCurrentTime = true;
        this.currentTimePercentage = currentTimePercentage;
      };
      setTime();
      setInterval(() => setTime(), 6e4);
    }
  }
});
const __injectCSSVars__$2 = () => {
  useCssVars((_ctx) => ({
    "bf39c726": _ctx.weekHeight
  }));
};
const __setup__$2 = __default__$2.setup;
__default__$2.setup = __setup__$2 ? (props, ctx) => {
  __injectCSSVars__$2();
  return __setup__$2(props, ctx);
} : __injectCSSVars__$2;
const _sfc_main$4 = __default__$2;
const _withScopeId$1 = (n) => (pushScopeId("data-v-426870cf"), n = n(), popScopeId(), n);
const _hoisted_1$4 = { class: "calendar-week__wrapper" };
const _hoisted_2$3 = { class: "calendar-week" };
const _hoisted_3$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("div", { class: "current-time-line__circle" }, null, -1));
const _hoisted_4$1 = [
  _hoisted_3$1
];
const _hoisted_5 = { class: "calendar-week__events" };
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_WeekTimeline = resolveComponent("WeekTimeline");
  const _component_EventFlyout = resolveComponent("EventFlyout");
  const _component_DayTimeline = resolveComponent("DayTimeline");
  const _component_Day = resolveComponent("Day");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_WeekTimeline, {
      days: _ctx.days,
      time: _ctx.time,
      "full-day-events": _ctx.fullDayEvents,
      config: _ctx.config,
      mode: _ctx.mode,
      onEventWasClicked: _ctx.handleClickOnEvent,
      onDayWasClicked: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("day-was-clicked", $event))
    }, null, 8, ["days", "time", "full-day-events", "config", "mode", "onEventWasClicked"]),
    createElementVNode("div", _hoisted_1$4, [
      !_ctx.config.eventDialog || !_ctx.config.eventDialog.isDisabled ? (openBlock(), createBlock(_component_EventFlyout, {
        key: 0,
        "calendar-event-prop": _ctx.selectedEvent,
        "event-element": _ctx.selectedEventElement,
        time: _ctx.time,
        config: _ctx.config,
        onHide: _cache[1] || (_cache[1] = ($event) => _ctx.selectedEvent = null),
        onEditEvent: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("edit-event", $event)),
        onDeleteEvent: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("delete-event", $event))
      }, {
        default: withCtx((p) => [
          renderSlot(_ctx.$slots, "eventDialog", {
            eventDialogData: p.eventDialogData,
            closeEventDialog: p.closeEventDialog
          }, void 0, true)
        ]),
        _: 3
      }, 8, ["calendar-event-prop", "event-element", "time", "config"])) : createCommentVNode("", true),
      createElementVNode("section", _hoisted_2$3, [
        _ctx.hasCustomCurrentTimeSlot && _ctx.showCurrentTime ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "custom-current-time",
          style: normalizeStyle({ top: `${_ctx.currentTimePercentage}%` })
        }, [
          renderSlot(_ctx.$slots, "customCurrentTime", {}, void 0, true)
        ], 4)) : _ctx.config && _ctx.config.showCurrentTime && _ctx.showCurrentTime ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "current-time-line",
          style: normalizeStyle({ top: `${_ctx.currentTimePercentage}%` })
        }, _hoisted_4$1, 4)) : createCommentVNode("", true),
        (openBlock(), createBlock(_component_DayTimeline, {
          key: _ctx.period.start.getTime() + _ctx.period.end.getTime() + _ctx.mode,
          time: _ctx.time,
          "day-intervals": _ctx.dayIntervals,
          "week-height": _ctx.weekHeight
        }, null, 8, ["time", "day-intervals", "week-height"])),
        createElementVNode("div", _hoisted_5, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.days, (day, dayIndex) => {
            return openBlock(), createBlock(_component_Day, {
              key: day.dateTimeString + _ctx.mode + _ctx.weekVersion,
              day,
              time: _ctx.time,
              config: _ctx.config,
              "day-info": { daysTotalN: _ctx.days.length, thisDayIndex: dayIndex },
              mode: _ctx.mode,
              "day-intervals": _ctx.dayIntervals,
              onEventWasClicked: _ctx.handleClickOnEvent,
              onEventWasResized: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("event-was-resized", $event)),
              onEventWasDragged: _ctx.handleEventWasDragged,
              onIntervalWasClicked: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("interval-was-clicked", $event)),
              onDayWasClicked: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("day-was-clicked", $event))
            }, {
              event: withCtx((p) => [
                renderSlot(_ctx.$slots, "event", {
                  eventData: p.eventData
                }, void 0, true)
              ]),
              _: 2
            }, 1032, ["day", "time", "config", "day-info", "mode", "day-intervals", "onEventWasClicked", "onEventWasDragged"]);
          }), 128))
        ])
      ])
    ])
  ], 64);
}
var Week = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__scopeId", "data-v-426870cf"]]);
var Event_vue_vue_type_style_index_0_scoped_true_lang = "";
const __default__$1 = defineComponent({
  name: "Event",
  props: {
    time: {
      type: Object,
      required: true
    },
    calendarEvent: {
      type: Object,
      required: true
    },
    config: {
      type: Object,
      required: true
    },
    day: {
      type: Object,
      required: true
    }
  },
  emits: ["event-was-clicked"],
  data() {
    return {
      colors: EVENT_COLORS,
      eventBackgroundColor: "",
      eventIdPrefix: "calendar-month__event-"
    };
  },
  computed: {
    eventTimeStart() {
      return DATE_TIME_STRING_PATTERN.test(this.calendarEvent.time.start) ? this.time.getLocalizedTime(this.calendarEvent.time.start) : null;
    },
    elementId() {
      return this.eventIdPrefix + this.calendarEvent.id + this.day.dateTimeString.substring(0, 10);
    },
    elementDraggableAttribute() {
      const {
        year: startYear,
        month: startMonth,
        date: startDate
      } = this.time.getAllVariablesFromDateTimeString(
        this.calendarEvent.time.start
      );
      const {
        year: endYear,
        month: endMonth,
        date: endDate
      } = this.time.getAllVariablesFromDateTimeString(
        this.calendarEvent.time.end
      );
      const eventIsSingleDay = startYear === endYear && startMonth === endMonth && startDate === endDate;
      const dragAndDropIsDisabled = this.calendarEvent.disableDnD && this.calendarEvent.disableDnD.includes("month");
      return this.calendarEvent.isEditable && eventIsSingleDay && !dragAndDropIsDisabled ? true : void 0;
    }
  },
  mounted() {
    this.setColors();
  },
  methods: {
    setColors() {
      var _a, _b, _c;
      if (((_a = this.calendarEvent) == null ? void 0 : _a.colorScheme) && ((_b = this.config.style) == null ? void 0 : _b.colorSchemes) && this.config.style.colorSchemes[this.calendarEvent.colorScheme]) {
        return this.eventBackgroundColor = this.config.style.colorSchemes[this.calendarEvent.colorScheme].backgroundColor;
      }
      if ((_c = this.calendarEvent) == null ? void 0 : _c.color) {
        return this.eventBackgroundColor = this.colors[this.calendarEvent.color];
      }
      return this.eventBackgroundColor = this.colors.blue;
    },
    handleClickOnEvent() {
      const eventElement2 = document.getElementById(this.elementId);
      this.$emit("event-was-clicked", {
        clickedEvent: this.calendarEvent,
        eventElement: eventElement2
      });
    },
    handleDragStart(dragEvent) {
      if (!dragEvent || !dragEvent.dataTransfer)
        return;
      dragEvent.dataTransfer.effectAllowed = "move";
      dragEvent.dataTransfer.setData(
        "json",
        JSON.stringify(this.calendarEvent)
      );
    }
  }
});
const __injectCSSVars__$1 = () => {
  useCssVars((_ctx) => ({
    "1ee79098": _ctx.eventBackgroundColor
  }));
};
const __setup__$1 = __default__$1.setup;
__default__$1.setup = __setup__$1 ? (props, ctx) => {
  __injectCSSVars__$1();
  return __setup__$1(props, ctx);
} : __injectCSSVars__$1;
const _sfc_main$3 = __default__$1;
const _withScopeId = (n) => (pushScopeId("data-v-7bf10a44"), n = n(), popScopeId(), n);
const _hoisted_1$3 = ["id", "draggable"];
const _hoisted_2$2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("span", { class: "calendar-month__event-color" }, null, -1));
const _hoisted_3 = {
  key: 0,
  class: "calendar-month__event-time"
};
const _hoisted_4 = { class: "calendar-month__event-title" };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    id: _ctx.elementId,
    class: normalizeClass(["calendar-month__event is-event", { "is-draggable": _ctx.elementDraggableAttribute }]),
    draggable: _ctx.elementDraggableAttribute,
    onDragstart: _cache[0] || (_cache[0] = (...args) => _ctx.handleDragStart && _ctx.handleDragStart(...args)),
    onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleClickOnEvent && _ctx.handleClickOnEvent(...args))
  }, [
    _hoisted_2$2,
    _ctx.eventTimeStart ? (openBlock(), createElementBlock("span", _hoisted_3, toDisplayString(_ctx.eventTimeStart), 1)) : createCommentVNode("", true),
    createElementVNode("span", _hoisted_4, toDisplayString(_ctx.calendarEvent.title), 1)
  ], 42, _hoisted_1$3);
}
var Event = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-7bf10a44"]]);
var Day_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$2 = defineComponent({
  name: "Day",
  components: { Event },
  mixins: [getLanguage],
  props: {
    config: {
      type: Object,
      required: true
    },
    time: {
      type: Object,
      required: true
    },
    day: {
      type: Object,
      required: true
    },
    isFirstWeek: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "event-was-clicked",
    "event-was-dragged",
    "updated-period",
    "day-was-clicked"
  ],
  data() {
    return {
      isActiveDroppable: false
    };
  },
  computed: {
    canBeDropped() {
      return this.isActiveDroppable;
    }
  },
  methods: {
    getMoreEvents() {
      const { date, month, year } = this.time.getAllVariablesFromDateTimeString(
        this.day.dateTimeString
      );
      const selectedDate = new Date(year, month, date);
      const week = this.time.getCalendarWeekDateObjects(selectedDate);
      const start = week[0];
      const end = week[6];
      this.$emit("updated-period", { start, end, selectedDate });
    },
    handleDragLeave() {
      this.isActiveDroppable = false;
    },
    handleDragEnd(mouseEvent) {
      this.isActiveDroppable = false;
      mouseEvent.stopPropagation();
    },
    handleDrop(dropEvent) {
      this.isActiveDroppable = false;
      dropEvent.stopPropagation();
      if (!dropEvent || !dropEvent.dataTransfer)
        return;
      const calendarEvent = JSON.parse(
        dropEvent.dataTransfer.getData("json")
      );
      const eventDroppedOnSameDay = this.time.dateStringsHaveEqualDates(
        calendarEvent.time.start,
        this.day.dateTimeString.substring(0, 10)
      );
      if (eventDroppedOnSameDay)
        return;
      calendarEvent.time.start = calendarEvent.time.start.replace(
        /^\d{4}-\d{2}-\d{2}/,
        this.day.dateTimeString.substring(0, 10)
      );
      calendarEvent.time.end = calendarEvent.time.end.replace(
        /^\d{4}-\d{2}-\d{2}/,
        this.day.dateTimeString.substring(0, 10)
      );
      this.$emit("event-was-dragged", calendarEvent);
    },
    handleDragOver(e) {
      this.isActiveDroppable = true;
      e.preventDefault();
      return false;
    },
    emitDayWasClicked() {
      this.$emit("day-was-clicked", this.day.dateTimeString.substring(0, 10));
    }
  }
});
const _hoisted_1$2 = ["id"];
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Event = resolveComponent("Event");
  return openBlock(), createElementBlock("div", {
    id: "day-" + _ctx.day.dateTimeString.substring(0, 10),
    class: normalizeClass(["calendar-month__weekday", { "is-droppable": _ctx.canBeDropped }]),
    onClick: _cache[4] || (_cache[4] = withModifiers((...args) => _ctx.emitDayWasClicked && _ctx.emitDayWasClicked(...args), ["self"])),
    onDragleave: _cache[5] || (_cache[5] = (...args) => _ctx.handleDragLeave && _ctx.handleDragLeave(...args)),
    onDragover: _cache[6] || (_cache[6] = (...args) => _ctx.handleDragOver && _ctx.handleDragOver(...args)),
    onDrop: _cache[7] || (_cache[7] = (...args) => _ctx.handleDrop && _ctx.handleDrop(...args)),
    onDragend: _cache[8] || (_cache[8] = (...args) => _ctx.handleDragEnd && _ctx.handleDragEnd(...args))
  }, [
    _ctx.isFirstWeek ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: "calendar-month__day-name",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.emitDayWasClicked && _ctx.emitDayWasClicked(...args))
    }, toDisplayString(_ctx.day.dayName), 1)) : createCommentVNode("", true),
    createElementVNode("span", {
      class: "calendar-month__day-date",
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.emitDayWasClicked && _ctx.emitDayWasClicked(...args))
    }, toDisplayString(_ctx.day.dateTimeString.substring(8, 10)), 1),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.day.events, (calendarEvent, index) => {
      return openBlock(), createElementBlock("div", {
        key: index,
        class: "calendar-month__event-wrapper"
      }, [
        index < 3 ? (openBlock(), createBlock(_component_Event, {
          key: calendarEvent.id,
          "calendar-event": calendarEvent,
          config: _ctx.config,
          time: _ctx.time,
          day: _ctx.day,
          onEventWasClicked: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("event-was-clicked", $event))
        }, null, 8, ["calendar-event", "config", "time", "day"])) : createCommentVNode("", true)
      ]);
    }), 128)),
    _ctx.day.events.length >= 4 ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: "calendar-month__weekday-more",
      onClick: _cache[3] || (_cache[3] = (...args) => _ctx.getMoreEvents && _ctx.getMoreEvents(...args))
    }, toDisplayString(_ctx.getLanguage(_ctx.languageKeys.moreEvents, _ctx.time.CALENDAR_LOCALE)), 1)) : createCommentVNode("", true)
  ], 42, _hoisted_1$2);
}
var Day = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-cd3b00be"]]);
var Month_vue_vue_type_style_index_0_scoped_true_lang = "";
const EventPositionHelper = new EventPosition();
const _sfc_main$1 = defineComponent({
  name: "Month",
  components: {
    Day,
    EventFlyout
  },
  props: {
    config: {
      type: Object,
      required: true
    },
    time: {
      type: Object,
      required: true
    },
    period: {
      type: Object,
      required: true
    },
    eventsProp: {
      type: Array,
      default: () => []
    }
  },
  emits: [
    "edit-event",
    "delete-event",
    "updated-period",
    "event-was-clicked",
    "event-was-dragged",
    "day-was-clicked"
  ],
  data() {
    return {
      month: [],
      selectedEvent: null,
      selectedEventElement: null,
      events: this.eventsProp,
      fullDayEvents: [],
      scrollbar: null
    };
  },
  mounted() {
    this.initMonth();
    this.initScrollbar();
  },
  methods: {
    initScrollbar(elapsedMs = 0) {
      const el = document.querySelector(".calendar-month");
      if (elapsedMs > 3e3)
        return;
      if (!el)
        this.initScrollbar(elapsedMs + 50);
      else {
        this.scrollbar = new PerfectScrollbar(el);
        this.scrollbar.update();
      }
    },
    initMonth() {
      this.month = [];
      this.sortOutFullDayEvents();
      this.setMonth();
    },
    setMonth() {
      const { month, fullYear } = new EDate(this.period.selectedDate);
      const calendarMonth = this.time.getCalendarMonthSplitInWeeks(
        fullYear,
        month
      );
      const monthWithEvents = calendarMonth.map((week) => {
        return week.map((day) => {
          const dateTimeString = this.time.getDateTimeStringFromDate(day);
          const events = this.events.filter((event) => {
            return event.time.start.substring(0, 11) === dateTimeString.substring(0, 11);
          });
          return {
            dayName: this.time.getLocalizedNameOfWeekday(day),
            dateTimeString: this.time.getDateTimeStringFromDate(day),
            events
          };
        });
      });
      this.month = EventPositionHelper.positionFullDayEventsInMonth(
        monthWithEvents,
        this.fullDayEvents
      );
    },
    sortOutFullDayEvents() {
      const timedEvents = [];
      const fullDayEvents = [];
      for (const calendarEvent of this.events) {
        if (DATE_TIME_STRING_PATTERN.test(calendarEvent.time.start))
          timedEvents.push(calendarEvent);
        else if (DATE_TIME_STRING_FULL_DAY_PATTERN.test(calendarEvent.time.start))
          fullDayEvents.push(calendarEvent);
      }
      this.events = timedEvents;
      this.fullDayEvents = fullDayEvents;
    },
    handleClickOnEvent(event) {
      this.$emit("event-was-clicked", event);
      this.selectedEventElement = event.eventElement;
      this.selectedEvent = event.clickedEvent;
    },
    handleEventWasDragged(calendarEvent) {
      this.$emit("event-was-dragged", calendarEvent);
      const newEvents = [...this.events, ...this.fullDayEvents].filter(
        (e) => e.id !== calendarEvent.id
      );
      newEvents.push(calendarEvent);
      this.events = [];
      this.fullDayEvents = [];
      this.events = newEvents;
      this.initMonth();
    }
  }
});
const _hoisted_1$1 = { class: "calendar-month" };
const _hoisted_2$1 = { class: "calendar-month__weeks" };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Day = resolveComponent("Day");
  const _component_EventFlyout = resolveComponent("EventFlyout");
  return openBlock(), createElementBlock("div", _hoisted_1$1, [
    createElementVNode("div", _hoisted_2$1, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.month, (week, weekIndex) => {
        return openBlock(), createElementBlock("div", {
          key: weekIndex,
          class: "calendar-month__week"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(week, (day, dayIndex) => {
            return openBlock(), createBlock(_component_Day, {
              key: dayIndex,
              "is-first-week": weekIndex === 0,
              config: _ctx.config,
              day,
              time: _ctx.time,
              onEventWasClicked: _ctx.handleClickOnEvent,
              onEventWasDragged: _ctx.handleEventWasDragged,
              onDayWasClicked: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("day-was-clicked", $event)),
              onUpdatedPeriod: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("updated-period", $event))
            }, null, 8, ["is-first-week", "config", "day", "time", "onEventWasClicked", "onEventWasDragged"]);
          }), 128))
        ]);
      }), 128))
    ]),
    !_ctx.config.eventDialog || !_ctx.config.eventDialog.isDisabled ? (openBlock(), createBlock(_component_EventFlyout, {
      key: 0,
      "calendar-event-prop": _ctx.selectedEvent,
      "event-element": _ctx.selectedEventElement,
      time: _ctx.time,
      config: _ctx.config,
      onHide: _cache[2] || (_cache[2] = ($event) => _ctx.selectedEvent = null),
      onEditEvent: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("edit-event", $event)),
      onDeleteEvent: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("delete-event", $event))
    }, {
      default: withCtx((p) => [
        renderSlot(_ctx.$slots, "eventDialog", {
          eventDialogData: p.eventDialogData,
          closeEventDialog: p.closeEventDialog
        }, void 0, true)
      ]),
      _: 3
    }, 8, ["calendar-event-prop", "event-element", "time", "config"])) : createCommentVNode("", true)
  ]);
}
var Month = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-25c5b5f2"]]);
class Errors {
  static checkEventProperties(event) {
    if (!event.id)
      console.warn(
        `${this.PREFIX} required event property 'id' is missing 
${this.SUFFIX}`
      );
    if (!event.title)
      console.warn(
        `${this.PREFIX} required event property 'title' is missing 
${this.SUFFIX}`
      );
    if (!event.time)
      console.warn(
        `${this.PREFIX} required event property 'time' is missing 
${this.SUFFIX}`
      );
    if (!event.time.start)
      console.warn(
        `${this.PREFIX} required event property 'time.start' is missing 
${this.SUFFIX}`
      );
    if (!event.time.end)
      console.warn(
        `${this.PREFIX} required event property 'time.end' is missing 
${this.SUFFIX}`
      );
    if (!["number", "string"].includes(typeof event.id))
      console.warn(
        `${this.PREFIX} event property 'id' expects a string or a number, received ${typeof event.id} 
${this.SUFFIX}`
      );
    if (typeof event.title !== "string")
      console.warn(
        `${this.PREFIX} event property 'title' expects a string, received ${typeof event.title} 
${this.SUFFIX}`
      );
    if (!DATE_TIME_STRING_PATTERN.test(event.time.start) && !DATE_TIME_STRING_FULL_DAY_PATTERN.test(event.time.start))
      console.warn(
        `${this.PREFIX} event property 'time.start' expects a string formatted like 'YYYY-MM-DD hh:mm', or 'YYYY-MM-DD', received ${event.time.start} 
${this.SUFFIX}`
      );
    if (!DATE_TIME_STRING_PATTERN.test(event.time.end) && !DATE_TIME_STRING_FULL_DAY_PATTERN.test(event.time.end))
      console.warn(
        `${this.PREFIX} event property 'time.end' expects a string formatted like 'YYYY-MM-DD hh:mm',  or 'YYYY-MM-DD', received ${event.time.end} 
${this.SUFFIX}`
      );
  }
  static checkConfig(config2) {
    if (config2.locale && !/^[a-z]{2}-[A-Z]{2}$/.test(config2.locale))
      console.warn(
        `${this.PREFIX} config.locale expects a string of format xx-XX, received: ${config2.locale}`
      );
    if (config2.defaultMode && !["month", "week", "day"].some((mode) => mode === config2.defaultMode))
      console.warn(
        `${this.PREFIX} config.defaultMode expects either one of the values "day", "week" or "month"`
      );
  }
}
__publicField(Errors, "PREFIX", "[Qalendar warning]");
__publicField(Errors, "SUFFIX", "");
var Qalendar_vue_vue_type_style_index_0_lang = "";
const __default__ = defineComponent({
  name: "Qalendar",
  components: {
    Month,
    AppHeader,
    Week
  },
  props: {
    config: {
      type: Object,
      default: () => ({})
    },
    events: {
      type: Array,
      default: () => []
    },
    selectedDate: {
      type: Date,
      default: new Date()
    },
    isLoading: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "event-was-clicked",
    "event-was-resized",
    "event-was-dragged",
    "updated-period",
    "updated-mode",
    "edit-event",
    "delete-event",
    "interval-was-clicked",
    "day-was-clicked"
  ],
  data() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    return {
      wasInitialized: 0,
      period: {
        start: new Date(),
        end: new Date(),
        selectedDate: this.selectedDate ? this.selectedDate : new Date()
      },
      mode: ((_a = this.config) == null ? void 0 : _a.defaultMode) || "week",
      time: new Time(
        (_c = (_b = this.config) == null ? void 0 : _b.week) == null ? void 0 : _c.startsOn,
        ((_d = this.config) == null ? void 0 : _d.locale) || null,
        {
          start: this.setTimePointsFromDayBoundary(((_f = (_e = this.config) == null ? void 0 : _e.dayBoundaries) == null ? void 0 : _f.start) || 0),
          end: this.setTimePointsFromDayBoundary(((_h = (_g = this.config) == null ? void 0 : _g.dayBoundaries) == null ? void 0 : _h.end) || 24)
        }
      ),
      fontFamily: ((_j = (_i = this.config) == null ? void 0 : _i.style) == null ? void 0 : _j.fontFamily) || "'Verdana', 'Open Sans', serif",
      eventRenderingKey: 0,
      eventsDataProperty: this.events || [],
      isSmall: false
    };
  },
  watch: {
    events: {
      deep: true,
      handler(newVal, oldVal) {
        if (JSON.stringify(newVal) !== JSON.stringify(oldVal)) {
          this.eventsDataProperty = newVal;
          this.eventRenderingKey = this.eventRenderingKey + 1;
        }
        if (this.config.isSilent)
          return;
        this.events.forEach((e) => Errors.checkEventProperties(e));
      },
      immediate: true
    },
    config: {
      deep: true,
      handler(value) {
        Errors.checkConfig(value);
      },
      immediate: true
    }
  },
  mounted() {
    this.setConfigOnMount();
    this.onCalendarResize();
    this.setPeriodOnMount();
    window.addEventListener("resize", this.onCalendarResize);
  },
  beforeUnmount() {
    window.removeEventListener("resize", this.onCalendarResize);
  },
  methods: {
    setConfigOnMount() {
      this.wasInitialized = 1;
    },
    handleUpdatedPeriod(value, leaveMonthMode = false) {
      this.$emit("updated-period", { start: value.start, end: value.end });
      this.period = value;
      if (leaveMonthMode)
        this.mode = this.isSmall ? "day" : "week";
    },
    handleChangeMode(payload) {
      if (payload === "day") {
        this.period.start = this.period.selectedDate;
        this.period.end = this.time.setDateToEndOfDay(this.period.selectedDate);
      }
      if (payload === "week") {
        const week = this.time.getCalendarWeekDateObjects(
          this.period.selectedDate
        );
        this.period.start = week[0];
        this.period.end = this.time.setDateToEndOfDay(week[6]);
      }
      if (payload === "month") {
        const month = this.time.getCalendarMonthSplitInWeeks(
          this.period.selectedDate.getFullYear(),
          this.period.selectedDate.getMonth()
        );
        this.period.start = month[0][0];
        const lastWeek = month[month.length - 1];
        this.period.end = this.time.setDateToEndOfDay(
          lastWeek[lastWeek.length - 1]
        );
      }
      this.mode = payload;
      this.$emit("updated-mode", { mode: payload, period: this.period });
    },
    onCalendarResize() {
      const documentRoot = document.documentElement;
      const calendarRoot = document.querySelector(".calendar-root");
      const documentFontSize = +window.getComputedStyle(documentRoot).fontSize.split("p")[0];
      const breakPointFor1RemEquals16px = 700;
      const multiplier = 16 / documentFontSize;
      const smallCalendarBreakpoint = breakPointFor1RemEquals16px / multiplier;
      if (!calendarRoot)
        return;
      this.isSmall = calendarRoot.clientWidth < smallCalendarBreakpoint;
      if (this.isSmall && !["day", "month"].includes(this.mode)) {
        this.mode = "day";
      }
    },
    setPeriodOnMount() {
      if (this.mode === "week") {
        const currentWeek = this.time.getCalendarWeekDateObjects(
          this.period.selectedDate
        );
        this.period.start = currentWeek[0];
        this.period.end = currentWeek[6];
      } else if (this.mode === "month") {
        const month = this.time.getCalendarMonthSplitInWeeks(
          this.period.selectedDate.getFullYear(),
          this.period.selectedDate.getMonth()
        );
        this.period.start = month[0][0];
        const lastWeek = month[month.length - 1];
        this.period.end = lastWeek[lastWeek.length - 1];
      }
    },
    handleEventWasUpdated(calendarEvent, eventType) {
      const newEvents = this.eventsDataProperty.filter(
        (e) => e.id !== calendarEvent.id
      );
      this.eventsDataProperty = [calendarEvent, ...newEvents];
      this.$emit(`event-was-${eventType}`, calendarEvent);
    },
    setTimePointsFromDayBoundary(boundary) {
      if (boundary < 0 || boundary > 24 || boundary % 1 !== 0)
        throw new Error("Invalid day boundary");
      if (boundary === 0)
        return boundary;
      return boundary * 100;
    }
  }
});
const __injectCSSVars__ = () => {
  useCssVars((_ctx) => ({
    "15201d04": _ctx.fontFamily
  }));
};
const __setup__ = __default__.setup;
__default__.setup = __setup__ ? (props, ctx) => {
  __injectCSSVars__();
  return __setup__(props, ctx);
} : __injectCSSVars__;
const _sfc_main = __default__;
const _hoisted_1 = { class: "calendar-root-wrapper" };
const _hoisted_2 = {
  key: 0,
  class: "top-bar-loader"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppHeader = resolveComponent("AppHeader");
  const _component_Week = resolveComponent("Week");
  const _component_Month = resolveComponent("Month");
  return openBlock(), createElementBlock("div", _hoisted_1, [
    createElementVNode("div", {
      class: normalizeClass(["calendar-root", {
        "mode-is-day": _ctx.mode === "day",
        "mode-is-week": _ctx.mode === "week",
        "mode-is-month": _ctx.mode === "month",
        "qalendar-is-small": _ctx.isSmall
      }])
    }, [
      createVNode(Transition, { name: "loading" }, {
        default: withCtx(() => [
          _ctx.isLoading ? (openBlock(), createElementBlock("div", _hoisted_2)) : createCommentVNode("", true)
        ]),
        _: 1
      }),
      (openBlock(), createBlock(_component_AppHeader, {
        key: _ctx.wasInitialized + _ctx.mode,
        config: _ctx.config,
        mode: _ctx.mode,
        time: _ctx.time,
        period: _ctx.period,
        "is-small": _ctx.isSmall,
        onChangeMode: _ctx.handleChangeMode,
        onUpdatedPeriod: _ctx.handleUpdatedPeriod
      }, null, 8, ["config", "mode", "time", "period", "is-small", "onChangeMode", "onUpdatedPeriod"])),
      ["week", "day"].includes(_ctx.mode) ? (openBlock(), createBlock(_component_Week, {
        key: _ctx.period.start.getTime() + _ctx.period.end.getTime() + _ctx.eventRenderingKey,
        "events-prop": _ctx.eventsDataProperty,
        period: _ctx.period,
        config: _ctx.config,
        "mode-prop": _ctx.mode,
        time: _ctx.time,
        onEventWasClicked: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("event-was-clicked", $event)),
        onEventWasResized: _cache[1] || (_cache[1] = ($event) => _ctx.handleEventWasUpdated($event, "resized")),
        onEventWasDragged: _cache[2] || (_cache[2] = ($event) => _ctx.handleEventWasUpdated($event, "dragged")),
        onEditEvent: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("edit-event", $event)),
        onDeleteEvent: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("delete-event", $event)),
        onIntervalWasClicked: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("interval-was-clicked", $event)),
        onDayWasClicked: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("day-was-clicked", $event))
      }, {
        event: withCtx((p) => [
          renderSlot(_ctx.$slots, "event", {
            eventData: p.eventData
          })
        ]),
        eventDialog: withCtx((p) => [
          renderSlot(_ctx.$slots, "eventDialog", {
            eventDialogData: p.eventDialogData,
            closeEventDialog: p.closeEventDialog
          })
        ]),
        customCurrentTime: withCtx(() => [
          renderSlot(_ctx.$slots, "customCurrentTime")
        ]),
        _: 3
      }, 8, ["events-prop", "period", "config", "mode-prop", "time"])) : createCommentVNode("", true),
      _ctx.mode === "month" ? (openBlock(), createBlock(_component_Month, {
        key: _ctx.period.start.getTime() + _ctx.period.end.getTime() + _ctx.eventRenderingKey,
        "events-prop": _ctx.eventsDataProperty,
        time: _ctx.time,
        config: _ctx.config,
        period: _ctx.period,
        onEventWasClicked: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("event-was-clicked", $event)),
        onDayWasClicked: _cache[8] || (_cache[8] = ($event) => _ctx.$emit("day-was-clicked", $event)),
        onEventWasDragged: _cache[9] || (_cache[9] = ($event) => _ctx.handleEventWasUpdated($event, "dragged")),
        onUpdatedPeriod: _cache[10] || (_cache[10] = ($event) => _ctx.handleUpdatedPeriod($event, true)),
        onEditEvent: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("edit-event", $event)),
        onDeleteEvent: _cache[12] || (_cache[12] = ($event) => _ctx.$emit("delete-event", $event))
      }, {
        eventDialog: withCtx((p) => [
          renderSlot(_ctx.$slots, "eventDialog", {
            eventDialogData: p.eventDialogData,
            closeEventDialog: p.closeEventDialog
          })
        ]),
        _: 3
      }, 8, ["events-prop", "time", "config", "period"])) : createCommentVNode("", true)
    ], 2)
  ]);
}
var Qalendar = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { DatePicker, Qalendar };
